{"version":3,"sources":["Background.js","Bullet.js","CollisionHelper.js","ContinueDialog.js","Enemy.js","Fighter.js","GLInitScene.js","Lighting.js","main.js","MainScene.js","MainScene2.js","PointLight.js","PositionHelper.js","ShotBullet.js","StageSequencer.js","TiledAsset.js","enemy/Middle1.js","enemy/TankSmall.js","enemy/Zako1.js","enemy/Zako2.js","glsprite/GLApp.js","glsprite/GLAppRenderer.js","glsprite/GLLoadingScene.js","glsprite/GLScene.js","glsprite/GLSingleSprite.js","glsprite/GLSprite.js","glsprite/GLTiledMap.js","glsprite/TextureAsset.js","stage/Stage1.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":["phina.namespace(() => {\r\n\r\n  phina.define(\"Background\", {\r\n    superClass: \"DisplayElement\",\r\n\r\n    init: function (params) {\r\n      this.superInit();\r\n\r\n      this.speed = params.speed;\r\n      const spriteArray = params.spriteArray;\r\n\r\n      this.fromJSON({\r\n        children: Array.range(0, 9).map(() => {\r\n          return {\r\n            className: \"GLSprite\",\r\n            arguments: {\r\n              spriteArray,\r\n              image: \"bg.png\",\r\n            },\r\n            scaleX: 512 / 1024, scaleY: 512 / 1024,\r\n            z: 20,\r\n          };\r\n        }),\r\n      });\r\n\r\n      this.scrollX = 0;\r\n      this.scrollY = 0;\r\n      this.vx = 0;\r\n      this.vy = 0;\r\n    },\r\n\r\n    update: function() {\r\n      this.scrollX += this.vx * this.speed;\r\n      this.scrollY += this.vy * this.speed;\r\n    },\r\n\r\n    _accessor: {\r\n      scrollX: {\r\n        get: function () {\r\n          return this._scrollX;\r\n        },\r\n        set: function (v) {\r\n          this._scrollX = v;\r\n          const base = CANVAS_WIDTH * 0.5 + this._scrollX % 512;\r\n          this.children[0].x = base + 512 * -1;\r\n          this.children[1].x = base + 512 * 0;\r\n          this.children[2].x = base + 512 * 1;\r\n          this.children[3].x = base + 512 * -1;\r\n          this.children[4].x = base + 512 * 0;\r\n          this.children[5].x = base + 512 * 1;\r\n          this.children[6].x = base + 512 * -1;\r\n          this.children[7].x = base + 512 * 0;\r\n          this.children[8].x = base + 512 * 1;\r\n        },\r\n      },\r\n      scrollY: {\r\n        get: function () {\r\n          return this._scrollY;\r\n        },\r\n        set: function (v) {\r\n          this._scrollY = v;\r\n          const base = CANVAS_HEIGHT * 0.5 + this._scrollY % 512;\r\n          this.children[0].y = base + 512 * -1;\r\n          this.children[1].y = base + 512 * -1;\r\n          this.children[2].y = base + 512 * -1;\r\n          this.children[3].y = base + 512 * 0;\r\n          this.children[4].y = base + 512 * 0;\r\n          this.children[5].y = base + 512 * 0;\r\n          this.children[6].y = base + 512 * 1;\r\n          this.children[7].y = base + 512 * 1;\r\n          this.children[8].y = base + 512 * 1;\r\n        },\r\n      },\r\n    },\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  phina.define(\"Bullet\", {\r\n    superClass: \"GLSprite\",\r\n\r\n    init: function (params) {\r\n      this.superInit({\r\n        spriteArray: params.spriteArray,\r\n        image: \"bullet0.png\",\r\n      });\r\n\r\n      this.bullet = null;\r\n      this.power = 0;\r\n      this.r = 0;\r\n      this.dummy = false;\r\n\r\n      this.setScale(0.5, 0.5);\r\n      this.brightness = 1.5;\r\n    },\r\n\r\n    update: function () {\r\n      this.x = this.bullet.x;\r\n      this.y = this.bullet.y;\r\n      this.rotation += 10;\r\n      if (this.x < CANVAS_WIDTH * -0.1 || CANVAS_WIDTH * 1.1 <= this.x || this.y < CANVAS_HEIGHT * -0.1 || CANVAS_HEIGHT * 1.1 <= this.y) {\r\n        this.remove();\r\n      }\r\n    },\r\n\r\n    setBullet: function (bullet, spec) {\r\n      this.x = bullet.x;\r\n      this.y = bullet.y;\r\n\r\n      this.bullet = bullet;\r\n      this.bullet.onVanish = () => this.remove();\r\n\r\n      this.power = 1;\r\n      this.r = 12;\r\n\r\n      this.dummy = false;\r\n      this.visible = true;\r\n\r\n      if (spec.label) {\r\n        if (spec.label.startsWith(\"dummy\")) {\r\n          this.dummy = true;\r\n          this.visible = false;\r\n        } else {\r\n          this.setImage(spec.label);\r\n        }\r\n      }\r\n    },\r\n\r\n    onremoved: function () {\r\n      this.bullet.destroy();\r\n      this.bullet = null;\r\n    },\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  const A = Vector2();\r\n  const B = Vector2();\r\n  const S = Vector2();\r\n  const V = Vector2();\r\n\r\n  phina.define(\"CollisionHelper\", {\r\n    _static: {\r\n\r\n      hitTestCircleCircle: function (a, b) {\r\n        // console.log(a.r, b.r);\r\n        return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) <= a.r + b.r;\r\n      },\r\n\r\n      hitTestCircleLine: function (circle, line) {\r\n        S.set(line.b.x - line.a.x, line.b.y - line.a.y);\r\n        A.set(circle.x - line.a.x, circle.y - line.a.y);\r\n        B.set(circle.x - line.b.x, circle.y - line.b.y);\r\n        const radSq = circle.r * circle.r;\r\n\r\n        if (A.lengthSquared() <= radSq || B.lengthSquared() <= radSq) {\r\n          return true;\r\n        } else if (Math.abs(Vector2.cross(S, A)) / S.length() > circle.r) {\r\n          return false;\r\n        } else {\r\n          return Vector2.dot(A, S) * Vector2.dot(B, S) <= 0;\r\n        }\r\n      },\r\n\r\n      raycast: function (origin, vector, circle) {\r\n        V.set(vector.x, vector.y);\r\n        V.normalize();\r\n\r\n        let ox = circle.x;\r\n        let oy = circle.y;\r\n        let r = circle.r;\r\n        let ax = origin.x;\r\n        let ay = origin.y;\r\n        let vx = V.x;\r\n        let vy = V.y;\r\n\r\n        if (vx === 0.0 && vy === 0.0) return null;\r\n\r\n        // 始点が円内にある場合は始点が衝突地点とする\r\n        if ((ax - ox) * (ax - ox) + (ay - oy) * (ay - oy) <= r * r) return origin;\r\n\r\n        // 円の中心点が原点になるように始点をオフセット\r\n        ax -= ox;\r\n        ay -= oy;\r\n\r\n        // 係数tを算出\r\n        const dotAV = ax * vx + ay * vy;\r\n        const dotAA = ax * ax + ay * ay;\r\n        let s = dotAV * dotAV - dotAA + r * r;\r\n        if (Math.abs(s) < 0.000001) {\r\n          s = 0.0; // 誤差修正\r\n        }\r\n\r\n        if (s < 0.0) return null; // 衝突していない\r\n\r\n        const sq = Math.sqrt(s);\r\n        const t1 = -dotAV - sq;\r\n        const t2 = -dotAV + sq;\r\n\r\n        // もしt1及びt2がマイナスだったら始点が\r\n        // 円内にめり込んでいるのでエラーとする\r\n        if (t1 < 0.0 || t2 < 0.0) return null;\r\n\r\n        // 衝突座標を出力\r\n        return {\r\n          x: ax + t1 * vx + ox,\r\n          y: ay + t1 * vy + oy\r\n        };\r\n        // { x: ax + t2 * vx + ox, y: ay + t2 * vy + oy };\r\n      },\r\n\r\n    },\r\n\r\n    init: function () { },\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  phina.define(\"ContinueDialog\", {\r\n    superClass: \"DisplayElement\",\r\n\r\n    init: function () {\r\n      this.superInit();\r\n\r\n      this.fromJSON({\r\n        children: {\r\n          label: {\r\n            className: \"Label\",\r\n            arguments: {\r\n              text: \"continue?\",\r\n              fill: \"white\",\r\n              stroke: null,\r\n              align: \"center\",\r\n              fontSize: 40,\r\n            },\r\n            x: CANVAS_WIDTH * 0.5,\r\n            y: CANVAS_HEIGHT * 0.4,\r\n          },\r\n          yes: {\r\n            className: \"Label\",\r\n            arguments: {\r\n              text: \"yes : [Z]key\",\r\n              fill: \"white\",\r\n              stroke: null,\r\n              align: \"center\",\r\n              fontSize: 30,\r\n            },\r\n            x: CANVAS_WIDTH * 0.25,\r\n            y: CANVAS_HEIGHT * 0.6,\r\n          },\r\n          no: {\r\n            className: \"Label\",\r\n            arguments: {\r\n              text: \"no : [X]key\",\r\n              fill: \"white\",\r\n              stroke: null,\r\n              align: \"center\",\r\n              fontSize: 30,\r\n            },\r\n            x: CANVAS_WIDTH * 0.75,\r\n            y: CANVAS_HEIGHT * 0.6,\r\n          },\r\n        },\r\n      });\r\n    },\r\n\r\n    update: function (app) {\r\n      if (app.controlMode == \"keyboard\") {\r\n        this.yes.text = \"yes : [Z]key\";\r\n        this.no.text = \"no : [X]key\";\r\n      } else if (app.controlMode == \"gamepad\") {\r\n        this.yes.text = \"yes : [A]button\";\r\n        this.no.text = \"no : [B]button\";\r\n      }\r\n\r\n      if (app.controlMode == \"gamepad\") {\r\n        const gp = app.gamepads.get();\r\n        if (gp.getKeyDown(\"a\")) {\r\n          this.flare(\"yes\");\r\n        } else if (gp.getKeyDown(\"b\")) {\r\n          this.flare(\"no\");\r\n        }\r\n      } else if (app.controlMode == \"keyboard\") {\r\n        const kb = app.keyboard;\r\n        if (kb.getKeyDown(\"z\")) {\r\n          this.flare(\"yes\");\r\n        } else if (kb.getKeyDown(\"x\")) {\r\n          this.flare(\"no\");\r\n        }\r\n      }\r\n    },\r\n  });\r\n});\r\n","phina.namespace(() => {\r\n\r\n  phina.define(\"Enemy\", {\r\n    superClass: \"DisplayElement\",\r\n\r\n    entered: false,\r\n    killed: false,\r\n\r\n    hp: 0,\r\n    r: 0,\r\n    power: 1,\r\n\r\n    bullet: null,\r\n    type: null,\r\n\r\n    init: function (params) {\r\n      this.superInit();\r\n\r\n      this.type = \"air\";\r\n      this.pubTw = Tweener().attachTo(this);\r\n\r\n      this.bullet = BulletML.Bullet.get();\r\n      if (params.bulletml) {\r\n        this.bulletml = AssetManager.get(\"xml\", params.bulletml).data;\r\n      }\r\n\r\n      this.entered = false;\r\n      this.killed = false;\r\n\r\n      this.tweener\r\n        .clear()\r\n        .wait(params.wait)\r\n        .call(() => this.start());\r\n    },\r\n\r\n    onremoved: function () {\r\n      if (this.bullet) {\r\n        this.bullet.destroy();\r\n        this.bullet = null;\r\n      }\r\n    },\r\n\r\n    start: function () {\r\n    },\r\n\r\n    pauseAttack: function () {\r\n      if (this.bullet && this.bullet.runner) {\r\n        this.bullet.runner.running = false;\r\n      }\r\n    },\r\n    resumeAttack: function () {\r\n      if (this.bullet && this.bullet.runner) {\r\n        this.bullet.runner.running = true;\r\n      }\r\n    },\r\n\r\n    update: function (app) {\r\n      if (this.bullet) {\r\n        this.bullet.x = this.x;\r\n        this.bullet.y = this.y;\r\n      }\r\n      if (!this.entered && this.inScreen()) {\r\n        this.entered = true;\r\n        this.flare(\"enter\");\r\n      }\r\n    },\r\n\r\n    damage: function (power) {\r\n      if (!this.entered) return false;\r\n\r\n      this.hp -= power;\r\n      const killed = this.hp <= 0;\r\n      if (killed) {\r\n        this.flare(\"killed\");\r\n      }\r\n\r\n      return killed;\r\n    },\r\n\r\n    inScreen: function () {\r\n      return 0 <= this.x && this.x < CANVAS_WIDTH && 0 <= this.y && this.y < CANVAS_HEIGHT;\r\n    },\r\n    inWorld: function () {\r\n      return CANVAS_WIDTH * -0.2 <= this.x && this.x < CANVAS_WIDTH * 1.2 && CANVAS_HEIGHT * -0.2 <= this.y && this.y < CANVAS_HEIGHT * 1.2;\r\n    },\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  const SPEED = 0.3;\r\n  const SPEED_SLOW = SPEED * 0.5;\r\n  const HEAT_BY_FIRE = 100;\r\n\r\n  const controller = {\r\n    moveDelta: Vector2(0, 0),\r\n    fire: false,\r\n    bomb: false,\r\n    slow: false,\r\n  };\r\n\r\n  phina.define(\"Fighter\", {\r\n    superClass: \"GLSprite\",\r\n\r\n    _static: {\r\n      instance: null,\r\n    },\r\n\r\n    init: function (params) {\r\n      this.superInit({\r\n        spriteArray: params.spriteArray,\r\n        image: \"fighterC4.png\",\r\n      });\r\n\r\n      Fighter.instance = this;\r\n\r\n      this.r = 0;\r\n      this.boundingType = \"circle\";\r\n      this.controllable = false;\r\n      this._muteki = true;\r\n      this.heat = 0;\r\n\r\n      this.controlMode = \"keyboard\";\r\n    },\r\n\r\n    update: function (app) {\r\n      if (this.controllable) {\r\n        const dt = app.deltaTime;\r\n\r\n        if (app.controlMode == \"gamepad\") {\r\n          const gp = app.gamepads.get();\r\n          const ls = gp.getStickDirection();\r\n\r\n          controller.moveDelta.x = Math.round(ls.x);\r\n          controller.moveDelta.y = Math.round(ls.y);\r\n          controller.fire = gp.getKey(\"r2\") || gp.getKey(\"x\");\r\n          controller.slow = gp.getKey(\"a\");\r\n        } else if (app.controlMode == \"keyboard\") {\r\n          const kb = app.keyboard;\r\n\r\n          controller.moveDelta.x = (kb.getKey(\"a\") || kb.getKey(\"left\")) ? -1 : (kb.getKey(\"d\") || kb.getKey(\"right\")) ? 1 : 0\r\n          controller.moveDelta.y = (kb.getKey(\"w\") || kb.getKey(\"up\")) ? -1 : (kb.getKey(\"s\") || kb.getKey(\"down\")) ? 1 : 0\r\n          controller.fire = kb.getKey(\"z\");\r\n          controller.slow = kb.getKey(\"shift\");\r\n        }\r\n\r\n        controller.moveDelta.normalize();\r\n        const speed = controller.slow ? SPEED_SLOW : SPEED;\r\n\r\n        this.position.x += controller.moveDelta.x * speed * dt;\r\n        this.position.y += controller.moveDelta.y * speed * dt;\r\n        this.position.x = Math.clamp(this.position.x, SCREEN_X + 10, SCREEN_X + SCREEN_W - 10);\r\n        this.position.y = Math.clamp(this.position.y, SCREEN_Y + 10, SCREEN_Y + SCREEN_H - 10);\r\n\r\n        if (controller.fire && this.heat <= 0) {\r\n          if (controller.slow) {\r\n            this.flare(\"firebullet\", { angle: Math.PI * -0.5 + 0.02, pos: { x: -24, y: 20 } });\r\n            this.flare(\"firebullet\", { angle: Math.PI * -0.5 + 0.01, pos: { x: -16, y: 20 } });\r\n            this.flare(\"firebullet\", { angle: Math.PI * -0.5, pos: { x: -6, y: 0 } });\r\n            this.flare(\"firebullet\", { angle: Math.PI * -0.5, pos: { x: 6, y: 0 } });\r\n            this.flare(\"firebullet\", { angle: Math.PI * -0.5 - 0.01, pos: { x: 16, y: 20 } });\r\n            this.flare(\"firebullet\", { angle: Math.PI * -0.5 - 0.02, pos: { x: 24, y: 20 } });\r\n          } else {\r\n            this.flare(\"firebullet\", { angle: Math.PI * -0.5 - 0.2, pos: { x: -24, y: 28 } });\r\n            this.flare(\"firebullet\", { angle: Math.PI * -0.5 - 0.1, pos: { x: -16, y: 20 } });\r\n            this.flare(\"firebullet\", { angle: Math.PI * -0.5, pos: { x: -6, y: 0 } });\r\n            this.flare(\"firebullet\", { angle: Math.PI * -0.5, pos: { x: 6, y: 0 } });\r\n            this.flare(\"firebullet\", { angle: Math.PI * -0.5 + 0.1, pos: { x: 16, y: 20 } });\r\n            this.flare(\"firebullet\", { angle: Math.PI * -0.5 + 0.2, pos: { x: 24, y: 28 } });\r\n          }\r\n          this.heat = HEAT_BY_FIRE;\r\n        }\r\n\r\n        this.heat -= dt;\r\n      } else {\r\n        this.heat = 0;\r\n      }\r\n    },\r\n\r\n    launch: function () {\r\n      this.tweener\r\n        .clear()\r\n        .set({\r\n          visible: true,\r\n          x: SCREEN_X + SCREEN_W * 0.2,\r\n          y: SCREEN_Y + SCREEN_H * 1.2,\r\n          controllable: false,\r\n          muteki: true,\r\n        })\r\n        .wait(1000)\r\n        .to({\r\n          y: SCREEN_Y + SCREEN_H * 0.9,\r\n        }, 800, \"easeOutBack\")\r\n        .set({\r\n          controllable: true,\r\n        })\r\n        .wait(1000)\r\n        .set({\r\n          muteki: false,\r\n        });\r\n\r\n      return this;\r\n    },\r\n\r\n    damage: function (power) {\r\n      // this.killed();\r\n    },\r\n\r\n    killed: function () {\r\n      this.controllable = false;\r\n      this.muteki = true;\r\n      this.flare(\"killed\");\r\n    },\r\n\r\n    _accessor: {\r\n      muteki: {\r\n        get: function () {\r\n          return this._muteki;\r\n        },\r\n        set: function (v) {\r\n          this._muteki = v;\r\n        },\r\n      }\r\n    }\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  phina.define(\"GLInitScene\", {\r\n    superClass: \"Scene\",\r\n\r\n    init: function (options) {\r\n      this.superInit();\r\n      \r\n      console.log(\"init begin\");\r\n\r\n      const renderer = options.app.renderer;\r\n      const spec = options.spriteArray;\r\n      for (let name in spec) {\r\n        renderer.addSpriteArray(name, spec[name].atlas, spec[name].max);\r\n      }\r\n      this.one(\"enterframe\", () => this.start());\r\n    },\r\n\r\n    start: function () {\r\n      this.exit();\r\n    },\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  phina.define(\"Lighting\", {\r\n\r\n    ambient: null,\r\n    pointLights: null,\r\n\r\n    init: function () {\r\n      this.ambient = [0, 0, 0, 1];\r\n      this.pointLights = Array.range(0, 8).map(index => {\r\n        const pl = PointLight({ index });\r\n        return pl;\r\n      });\r\n    },\r\n\r\n  });\r\n\r\n});\r\n","const CANVAS_WIDTH = 512;\r\nconst CANVAS_HEIGHT = 512;\r\nconst SCREEN_X = 64;\r\nconst SCREEN_Y = 0;\r\nconst SCREEN_W = 384;\r\nconst SCREEN_H = 512;\r\n\r\nphina.main(() => {\r\n\r\n  const app = GLApp({ width: CANVAS_WIDTH, height: CANVAS_HEIGHT });\r\n  app.replaceScene(ManagerScene({\r\n    scenes: [{\r\n      label: \"loading\",\r\n      className: \"GLLoadingScene\",\r\n      arguments: {\r\n        assets: {\r\n          image: {\r\n            \"black\": \"./asset/image/black.png\",\r\n            \"no_normal\": \"./asset/image/no_normal.png\",\r\n            \"test\": \"./asset/test/fighter_big.png\",\r\n            \"test_n\": \"./asset/test/fighter_big_n.png\",\r\n          },\r\n          xml: {\r\n            \"test\": \"./asset/bulletml/test.xml\",\r\n          },\r\n          atlas: {\r\n            \"common\": \"./asset/image/common.json\",\r\n          },\r\n          vertexShader: {\r\n            \"glsprite.vs\": \"./asset/shader/glsprite.vs\",\r\n            \"glsinglesprite.vs\": \"./asset/shader/glsinglesprite.vs\",\r\n            \"gltiledmap.vs\": \"./asset/shader/gltiledmap.vs\",\r\n          },\r\n          fragmentShader: {\r\n            \"glsprite.fs\": \"./asset/shader/glsprite.fs\",\r\n            \"glsinglesprite.fs\": \"./asset/shader/glsinglesprite.fs\",\r\n            \"gltiledmap.fs\": \"./asset/shader/gltiledmap.fs\",\r\n          },\r\n          tiled: {\r\n            \"test\": \"./asset/map/test.json\",\r\n          },\r\n        },\r\n      },\r\n    }, {\r\n      label: \"glinit\",\r\n      className: \"GLInitScene\",\r\n      arguments: {\r\n        common: { atlas: \"common\", max: 3000 },\r\n      },\r\n    }, {\r\n      label: \"main\",\r\n      className: \"MainScene2\",\r\n      arguments: {\r\n        app: app,\r\n      },\r\n    }],\r\n  }));\r\n\r\n  app.gamepads = GamepadManager();\r\n  app.update = () => {\r\n    app.gamepads.update();\r\n\r\n    const gp = app.gamepads.get();\r\n    if (gp) {\r\n      if ((0.5 * 0.5) < gp.getStickDirection(0).lengthSquared() || (0.5 * 0.5) < gp.getStickDirection(1).lengthSquared() || gp.buttons.some(b => b.down)) {\r\n        app.controlMode = \"gamepad\";\r\n      }\r\n    }\r\n  };\r\n  app.enableStats();\r\n  app.run();\r\n\r\n  document.addEventListener(\"keydown\", () => app.controlMode = \"keyboard\");\r\n  document.addEventListener(\"mousedown\", () => app.controlMode = \"keyboard\");\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  phina.define(\"MainScene\", {\r\n    superClass: \"DisplayScene\",\r\n\r\n    init: function () {\r\n      this.superInit();\r\n\r\n      this.fromJSON({\r\n        children: {\r\n          seq: { className: \"Stage1\" },\r\n          bgC: {\r\n            className: \"RectangleShape\",\r\n            arguments: {\r\n              fill: (() => {\r\n                const c = document.createElement(\"canvas\");\r\n                c.width = CANVAS_WIDTH;\r\n                c.height = CANVAS_HEIGHT;\r\n                const ctx = c.getContext(\"2d\");\r\n                const gra = ctx.createRadialGradient(0, CANVAS_HEIGHT * -0.2, 0, 0, 0, CANVAS_HEIGHT * 0.5);\r\n                gra.addColorStop(0.0, \"hsl(220, 90%, 10%)\");\r\n                gra.addColorStop(1.0, \"hsl(220, 90%, 0%)\");\r\n                return gra;\r\n              })(),\r\n              stroke: null,\r\n              padding: 0,\r\n              width: CANVAS_WIDTH,\r\n              height: CANVAS_HEIGHT,\r\n            },\r\n            originX: 0,\r\n            originY: 0,\r\n          },\r\n          bg0: { className: \"Background\", arguments: { speed: 1.0 }, scaleX: 1, scaleY: 1 },\r\n          bg1: { className: \"Background\", arguments: { speed: 0.8 }, scaleX: 0.8, scaleY: 0.8, alpha: 0.5 },\r\n          fighterLayer: { className: \"DisplayElement\" },\r\n          shotLayer: { className: \"DisplayElement\" },\r\n          enemyLayer: { className: \"DisplayElement\" },\r\n          effectLayer: { className: \"DisplayElement\" },\r\n          bulletLayer: { className: \"DisplayElement\" },\r\n          black: {\r\n            className: \"RectangleShape\",\r\n            arguments: {\r\n              fill: \"black\",\r\n              stroke: null,\r\n              padding: 0,\r\n              width: CANVAS_WIDTH,\r\n              height: CANVAS_HEIGHT,\r\n            },\r\n            originX: 0,\r\n            originY: 0,\r\n          },\r\n          uiLayer: { className: \"DisplayElement\" },\r\n        },\r\n      });\r\n\r\n      // fighter\r\n      const fighter = Fighter().hide();\r\n      fighter.on(\"firebullet\", ({ angle, pos }) => {\r\n        const shot = this.shotBullets.find(s => !s.parent);\r\n        if (shot) {\r\n          shot\r\n            .setAngle(angle)\r\n            .setPosition(fighter.x + pos.x, fighter.y + pos.y)\r\n            .addChildTo(this.shotLayer);\r\n        } else {\r\n          console.log(\"ショットたりない\");\r\n        }\r\n      });\r\n      fighter.on(\"killed\", () => {\r\n        this.black.tweener.clear().fadeIn(500);\r\n        fighter.remove();\r\n        this.vanishAllEnemy();\r\n        this.seq.flare(\"miss\");\r\n        const dialog = ContinueDialog().addChildTo(this.uiLayer);\r\n        dialog.on(\"yes\", () => {\r\n          dialog.remove();\r\n          this.restart();\r\n        });\r\n        dialog.on(\"no\", () => {\r\n          dialog.remove();\r\n          this.exit();\r\n        });\r\n      });\r\n      this.fighter = fighter;\r\n\r\n      // shot\r\n      this.shotBullets = Array.range(0, 300).map(() => ShotBullet());\r\n\r\n      // bullet\r\n      this.bullets = Array.range(0, 3000).map(() => Bullet());\r\n      const bulletmlManager = new BulletML.Manager({ player: fighter });\r\n      this.on(\"enterframe\", () => bulletmlManager.update());\r\n      bulletmlManager.onFire = ({ bullet, spec }) => {\r\n        const b = this.bullets.find(b => !b.parent);\r\n        if (b) {\r\n          b.setBullet(bullet, spec);\r\n        } else {\r\n          console.log(\"弾たりない\");\r\n        }\r\n        b.addChildTo(this.bulletLayer);\r\n      };\r\n      this.bulletmlManager = bulletmlManager;\r\n\r\n      // enemy\r\n      this.enemies = [];\r\n      this.seq.on(\"launch\", ({ enemy }) => {\r\n        this.enemies.push(enemy);\r\n        enemy.on(\"effect\", ({ type }) => {\r\n          switch (type) {\r\n            case \"smallExplosion\":\r\n              break;\r\n            case \"middleExplosion\":\r\n              break;\r\n            case \"largeExplosion\":\r\n              break;\r\n          }\r\n        });\r\n        enemy.on(\"killed\", () => {\r\n          enemy.remove();\r\n        });\r\n        enemy.on(\"removed\", () => this.enemies.erase(enemy));\r\n        if (enemy.bulletml) {\r\n          enemy.on(\"attack\", () => {\r\n            const bulletmlRoot = BulletML.parse(enemy.bulletml);\r\n            bulletmlManager.run(enemy.bullet, bulletmlRoot);\r\n          });\r\n        }\r\n        enemy.addChildTo(this.enemyLayer);\r\n      });\r\n\r\n      // stage\r\n      this.seq.on(\"changescroll\", ({ x, y, duration }) => {\r\n        this.bg0.tweener.clear().to({ vx: x, vy: y }, duration);\r\n        this.bg1.tweener.clear().to({ vx: x, vy: y }, duration);\r\n      });\r\n      this.seq.on(\"checkpoint\", () => {\r\n        console.log(\"checkpoint\");\r\n      });\r\n\r\n      this.one(\"enterframe\", () => this.restart());\r\n    },\r\n\r\n    restart: function () {\r\n      this.black.tweener.clear().fadeOut(500);\r\n      this.seq.restart();\r\n      this.fighter.addChildTo(this.fighterLayer);\r\n      this.fighter.launch();\r\n    },\r\n\r\n    update: function () {\r\n      // ショットvs敵\r\n      for (let i = 0, il = this.shotBullets.length; i < il; i++) {\r\n        const s = this.shotBullets[i];\r\n        if (s.parent) {\r\n          for (let j = 0, jl = this.enemies.length; j < jl; j++) {\r\n            const e = this.enemies[j];\r\n            if (CollisionHelper.hitTestCircleLine(e, s)) {\r\n              if (e.damage(s.power)) {\r\n                this.enemies.erase(e);\r\n              }\r\n              const hitPoint = CollisionHelper.raycast(s.a, s.velocity, e);\r\n              if (hitPoint) {\r\n                this.hitEffect(hitPoint.x, hitPoint.y);\r\n              }\r\n              s.remove();\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!this.fighter.muteki) {\r\n        // 敵vs自機\r\n        for (let i = 0, il = this.enemies.length; i < il; i++) {\r\n          const e = this.enemies[i];\r\n          if (e.parent && e.type == \"air\") {\r\n            if (CollisionHelper.hitTestCircleCircle(e, this.fighter)) {\r\n              this.fighter.damage(e.power);\r\n            }\r\n          }\r\n        }\r\n\r\n        // 弾vs自機\r\n        for (let i = 0, il = this.bullets.length; i < il; i++) {\r\n          const b = this.bullets[i];\r\n          if (b.parent && !b.dummy) {\r\n            if (CollisionHelper.hitTestCircleCircle(b, this.fighter)) {\r\n              this.fighter.damage(b.power);\r\n              b.remove();\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        this.vanishAllBullet();\r\n      }\r\n\r\n      // 地上物移動\r\n      for (let i = 0, il = this.enemies.length; i < il; i++) {\r\n        const e = this.enemies[i];\r\n        if (e.parent && e.type == \"ground\") {\r\n          e.x += this.bg0.vx;\r\n          e.y += this.bg0.vy;\r\n        }\r\n      }\r\n    },\r\n\r\n    vanishAllEnemy: function () {\r\n      this.enemies.forEach(e => {\r\n        e.pubTw\r\n          .clear()\r\n          .fadeOut(500)\r\n          .call(() => e.remove());\r\n      });\r\n    },\r\n\r\n    vanishAllBullet: function () {\r\n      this.bullets.forEach(b => {\r\n        if (b.parent) {\r\n          b.remove();\r\n          this.vanishEffect(b.x, b.y);\r\n        }\r\n      });\r\n    },\r\n\r\n    hitEffect: function (x, y) {\r\n\r\n    },\r\n\r\n    vanishEffect: function (x, y) {\r\n\r\n    },\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  // Z値\r\n  // BG 20\r\n  // Enemy 30\r\n  // Fighter 40\r\n  // Shot 50\r\n  // Effect 60\r\n  // Bullet 70～100\r\n  // UI 100～\r\n\r\n  phina.define(\"MainScene2\", {\r\n    superClass: \"GLScene\",\r\n\r\n    init: function (params) {\r\n      this.superInit();\r\n\r\n      const renderer = params.app.renderer;\r\n      const gl = params.app.gl;\r\n\r\n      const commonArray = renderer.getSpriteArray(\"common\");\r\n\r\n      this.bulletTree = new DaiCol.LinearQuadTreeSpace(CANVAS_WIDTH, CANVAS_HEIGHT, 2);\r\n      this.enemyTree = new DaiCol.LinearQuadTreeSpace(CANVAS_WIDTH, CANVAS_HEIGHT, 2);\r\n      this.shotBulletTree = new DaiCol.LinearQuadTreeSpace(CANVAS_WIDTH, CANVAS_HEIGHT, 2);\r\n      this.fighterTree = new DaiCol.LinearQuadTreeSpace(CANVAS_WIDTH, CANVAS_HEIGHT, 2);\r\n\r\n      this.fromJSON({\r\n        children: {\r\n          seq: { className: \"Stage1\" },\r\n          sideL: {\r\n            className: \"GLSprite\",\r\n            arguments: {\r\n              spriteArray: commonArray,\r\n              image: \"black.png\",\r\n            },\r\n            originX: 0, originY: 0,\r\n            scaleX: SCREEN_X / 32, scaleY: SCREEN_H / 32,\r\n            z: 100,\r\n          },\r\n          sideR: {\r\n            className: \"GLSprite\",\r\n            arguments: {\r\n              spriteArray: commonArray,\r\n              image: \"black.png\",\r\n            },\r\n            originX: 1, originY: 0,\r\n            scaleX: (CANVAS_WIDTH - SCREEN_X - SCREEN_W) / 32, scaleY: SCREEN_H / 32,\r\n            x: CANVAS_WIDTH,\r\n            z: 100,\r\n          },\r\n          // bg: { className: \"Background\", arguments: { spriteArray: commonArray, speed: 1.0 } },\r\n          black: {\r\n            className: \"GLSprite\",\r\n            arguments: {\r\n              spriteArray: commonArray,\r\n              image: \"black.png\",\r\n              alphaEnabled: true,\r\n            },\r\n            originX: 0, originY: 0,\r\n            scaleX: CANVAS_WIDTH / 32, scaleY: CANVAS_HEIGHT / 32,\r\n            z: 100,\r\n          },\r\n        },\r\n      });\r\n\r\n      // fighter\r\n      const fighter = Fighter({ spriteArray: commonArray })\r\n        .setZ(40)\r\n        .hide();\r\n      fighter.on(\"firebullet\", ({ angle, pos }) => {\r\n        const shot = this.shotBullets.find(s => !s.parent);\r\n        if (shot) {\r\n          shot\r\n            .setAngle(angle)\r\n            .setPosition(fighter.x + pos.x, fighter.y + pos.y)\r\n            .addChildTo(this);\r\n        } else {\r\n          console.log(\"ショットたりない\");\r\n        }\r\n      });\r\n      fighter.on(\"killed\", () => {\r\n        this.black.tweener.clear().fadeIn(500);\r\n        fighter.remove();\r\n        this.vanishAllEnemy();\r\n        this.seq.flare(\"miss\");\r\n        // const dialog = ContinueDialog().addChildTo(this.uiLayer);\r\n        // dialog.on(\"yes\", () => {\r\n        //   dialog.remove();\r\n        //   this.restart();\r\n        // });\r\n        // dialog.on(\"no\", () => {\r\n        //   dialog.remove();\r\n        //   this.exit();\r\n        // });\r\n      });\r\n      this.fighter = fighter;\r\n\r\n      // shot\r\n      this.shotBullets = Array.range(0, 300).map(() => {\r\n        return ShotBullet({ spriteArray: commonArray }).setZ(50);\r\n      });\r\n\r\n      // bullet\r\n      this.bullets = Array.range(0, 7000).map(() => {\r\n        return Bullet({ spriteArray: commonArray });\r\n      });\r\n      const bulletmlManager = new BulletML.Manager({ player: fighter });\r\n      this.on(\"enterframe\", () => bulletmlManager.update());\r\n      let bulletZ = 70;\r\n      bulletmlManager.onFire = ({ bullet, spec }) => {\r\n        const b = this.bullets.find(b => !b.parent);\r\n        if (b) {\r\n          b.setBullet(bullet, spec);\r\n          bulletZ += 0.001;\r\n          if (100 < bulletZ) bulletZ = 70;\r\n          b.setZ(bulletZ);\r\n          b.addChildTo(this);\r\n        } else {\r\n          console.log(\"弾たりない\");\r\n        }\r\n      };\r\n      this.bulletmlManager = bulletmlManager;\r\n\r\n      // enemy\r\n      this.enemies = [];\r\n\r\n      // stage\r\n      this.seq.on(\"changescroll\", ({ x, y, duration }) => {\r\n        this.bg.tweener.clear().to({ vx: x, vy: y }, duration);\r\n      });\r\n      this.seq.on(\"checkpoint\", () => {\r\n        console.log(\"checkpoint\");\r\n      });\r\n\r\n      this.one(\"enterframe\", () => this.restart());\r\n\r\n      GLTiledMap({ gl, tiledAsset: \"test\" })\r\n        .setZ(20.1)\r\n        .addChildTo(this);\r\n      GLSingleSprite({ gl, image: \"test\" })\r\n        .setPosition(256, 100)\r\n        .setZ(40.1)\r\n        .addChildTo(this);\r\n    },\r\n\r\n    restart: function () {\r\n      this.black.tweener.clear().fadeOut(500);\r\n      // this.seq.restart();\r\n      this.fighter.addChildTo(this);\r\n      this.fighter.launch();\r\n    },\r\n\r\n    update: function () {\r\n      const bulletTree = this.bulletTree;\r\n      const enemyTree = this.enemyTree;\r\n      const shotBulletTree = this.shotBulletTree;\r\n      const fighterTree = this.fighterTree;\r\n\r\n      bulletTree.clear();\r\n      for (let i = 0, len = this.bullets.length; i < len; i++) {\r\n        const b = this.bullets[i];\r\n        if (b.parent || b.visible) bulletTree.addActor(b);\r\n      }\r\n      enemyTree.clear();\r\n      for (let i = 0, len = this.enemies.length; i < len; i++) {\r\n        const e = this.enemies[i];\r\n        if (e.parent && e.visible) enemyTree.addActor(e);\r\n      }\r\n      shotBulletTree.clear();\r\n      for (let i = 0, len = this.shotBullets.length; i < len; i++) {\r\n        const s = this.shotBullets[i];\r\n        if (s.parent) shotBulletTree.addActor(s);\r\n      }\r\n      fighterTree.clear();\r\n      if (this.fighter.parent && !this.fighter.muteki) fighterTree.addActor(this.fighter);\r\n\r\n      // shot vs enemy\r\n      DaiCol.hitTest(shotBulletTree, enemyTree, (s, e) => {\r\n        if (s.parent && e.parent) {\r\n          if (CollisionHelper.hitTestCircleLine(e, s)) {\r\n            e.damage(s.power);\r\n            s.hit();\r\n          }\r\n        }\r\n      });\r\n\r\n      // fighter vs bullet\r\n      if (this.fighter.parent && !this.fighter.muteki) {\r\n        DaiCol.hitTest(fighterTree, bulletTree, (f, b) => {\r\n          if (f.parent && b.parent) {\r\n            if (CollisionHelper.hitTestCircleCircle(f, b)) {\r\n              f.damage(b.power);\r\n              b.remove();\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      // fighter vs enemy\r\n      if (this.fighter.parent && !this.fighter.muteki) {\r\n        DaiCol.hitTest(fighterTree, enemyTree, (f, e) => {\r\n          if (f.parent && e.parent && e.type === \"air\") {\r\n            if (CollisionHelper.hitTestCircleCircle(f, e)) {\r\n              f.damage(e.power);\r\n            }\r\n          }\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  phina.define(\"PointLight\", {\r\n    superClass: \"DisplayElement\",\r\n\r\n    index: 0,\r\n    z: 0,\r\n\r\n    r: 0,\r\n    g: 0,\r\n    b: 0,\r\n    power: 0,\r\n\r\n    init: function (options) {\r\n      options = ({}).$extend(PointLight.defaults, options);\r\n      this.superInit(options);\r\n      this.index = options.index;\r\n      this.z = options.z;\r\n    },\r\n\r\n    setZ: function (value) {\r\n      this.z = value;\r\n      return this;\r\n    },\r\n\r\n    set: function (drawable) {\r\n      const uni = drawable.uniforms;\r\n      const i = this.index;\r\n      if (this.parent && this.visible) {\r\n        uni[`lightColor[${i}]`].setValue([this.r / 255, this.g / 255, this.b / 255, 1]);\r\n        uni[`lightPower[${i}]`].setValue(this.power);\r\n        uni[`lightPosition[${i}]`].setValue([this.x, this.y, this.z]);\r\n      } else {\r\n        uni[`lightColor[${i}]`].setValue([0, 0, 0, 1]);\r\n        uni[`lightPower[${i}]`].setValue(0);\r\n        uni[`lightPosition[${i}]`].setValue([0, 0, 0]);\r\n      }\r\n    },\r\n\r\n    _static: {\r\n      defaults: {\r\n        z: 30,\r\n        power: 0,\r\n      },\r\n    },\r\n\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  const TEMP_V = Vector2();\r\n  const TEMP_M = Matrix33();\r\n\r\n  phina.define(\"PositionHelper\", {\r\n    _static: {\r\n\r\n      rotate: function (x, y, angle) {\r\n        const p = TEMP_V.set(x, y);\r\n        const m = TEMP_M.set(\r\n          Math.cos(angle), -Math.sin(angle), 0,\r\n          Math.sin(angle), Math.cos(angle), 0,\r\n          0, 0, 1,\r\n        );\r\n\r\n        return m.multiplyVector2(p);\r\n      },\r\n\r\n    },\r\n\r\n    init: function () { },\r\n  });\r\n});\r\n","phina.namespace(() => {\r\n\r\n  const SPEED = 18;\r\n\r\n  phina.define(\"ShotBullet\", {\r\n    superClass: \"GLSprite\",\r\n\r\n    init: function (params) {\r\n      this.superInit({\r\n        spriteArray: params.spriteArray,\r\n        image: \"black.png\",\r\n      });\r\n\r\n      this.power = 1;\r\n      this.r = 1;\r\n\r\n      this.beforePosition = Vector2(0, 0);\r\n      this.velocity = Vector2(0, 0);\r\n    },\r\n\r\n    setAngle: function (rad) {\r\n      this.velocity.fromAngle(rad, SPEED);\r\n      this.rotation = rad.toDegree() + 90;\r\n      return this;\r\n    },\r\n\r\n    update: function () {\r\n      this.beforePosition.set(this.x, this.y);\r\n      this.x += this.velocity.x;\r\n      this.y += this.velocity.y;\r\n\r\n      if (this.x < 0 || CANVAS_WIDTH <= this.x || this.y < 0 || CANVAS_HEIGHT <= this.y) {\r\n        this.remove();\r\n      }\r\n    },\r\n\r\n    hit: function () {\r\n      this.remove();\r\n    },\r\n\r\n    _accessor: {\r\n      a: {\r\n        get: function () {\r\n          return this.beforePosition;\r\n        },\r\n      },\r\n      b: {\r\n        get: function () {\r\n          return this.position;\r\n        },\r\n      },\r\n      left: {\r\n        get: function () {\r\n          return Math.min(this.a.x, this.b.x);\r\n        },\r\n        set: function () { },\r\n      },\r\n      right: {\r\n        get: function () {\r\n          return Math.max(this.a.x, this.b.x);\r\n        },\r\n        set: function () { },\r\n      },\r\n      top: {\r\n        get: function () {\r\n          return Math.min(this.a.y, this.b.y);\r\n        },\r\n        set: function () { },\r\n      },\r\n      bottom: {\r\n        get: function () {\r\n          return Math.max(this.a.y, this.b.y);\r\n        },\r\n        set: function () { },\r\n      },\r\n    },\r\n  });\r\n});\r\n","phina.namespace(() => {\r\n\r\n  phina.define(\"StageSequencer\", {\r\n    superClass: \"Element\",\r\n\r\n    init: function () {\r\n      this.superInit();\r\n\r\n      this.wait = 0;\r\n      this.val = { done: false };\r\n\r\n      this.enemies = [];\r\n      this.checkPoint = 0;\r\n    },\r\n\r\n    gen: function* () { },\r\n\r\n    restart: function () {\r\n      this.ite = this.gen();\r\n    },\r\n    onmiss: function () {\r\n    },\r\n    oncheckpoint: function () {\r\n      this.enemies.clear();\r\n      this.checkPoint += 1;\r\n    },\r\n\r\n    update: function (app) {\r\n      if (Fighter.instance.parent) {\r\n        this.wait -= app.deltaTime;\r\n        if (this.ite) {\r\n          while (!this.val.done && this.wait <= 0) {\r\n            this.val = this.ite.next();\r\n            this.wait = this.val.value;\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    launchEnemy: function (className, params, x, y, areaCount = true) {\r\n      const enemy = phina.using(className)(params);\r\n      enemy.x = x + CANVAS_WIDTH * 0.5;\r\n      enemy.y = y;\r\n      this.flare(\"launch\", { enemy });\r\n      if (areaCount) this.enemies.push(enemy);\r\n      return enemy;\r\n    },\r\n\r\n    startMusic: function (name, fadeTime, loop) {\r\n      this.flare(\"startmusic\", { name, fadeTime, loop });\r\n    },\r\n\r\n    stopMusic: function (fadeTime) {\r\n      this.flare(\"stopmusic\", { fadeTime });\r\n    },\r\n\r\n    changeScroll: function (x, y, duration) {\r\n      this.flare(\"changescroll\", { x, y, duration });\r\n    },\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  phina.define(\"TiledAsset\", {\r\n    superClass: \"phina.asset.Asset\",\r\n\r\n    init: function () {\r\n      this.superInit();\r\n      this.tilesets = null;\r\n    },\r\n\r\n    _load: function (resolve) {\r\n      const src = this.src.startsWith(\"/\") ? this.src : \"./\" + this.src;\r\n      const basePath = src.substring(0, src.lastIndexOf(\"/\") + 1);\r\n      fetch(src)\r\n        .then(res => res.json())\r\n        .then(json => {\r\n          this.json = json;\r\n          Promise.all(\r\n            json.tilesets.map((ts, id) => Tileset(id, ts).load(basePath + ts.source))\r\n          ).then(tilesets => {\r\n            this.tilesets = tilesets;\r\n            resolve(this);\r\n          });\r\n        });\r\n    },\r\n  });\r\n\r\n  phina.define(\"Tileset\", {\r\n    init: function (id, tileset) {\r\n      this.id = id;\r\n      this.image = null;\r\n      this.normalImage = null;\r\n      this.firstgid = tileset.firstgid;\r\n      this.source = tileset.source;\r\n\r\n      this.json = null;\r\n      this.tilewidth = 0;\r\n      this.tileheight = 0;\r\n      this.imagewidth = 0;\r\n      this.imageheight = 0;\r\n      this.cols = 0;\r\n      this.rows = 0;\r\n    },\r\n\r\n    load: function (path) {\r\n      return new Promise(resolve => {\r\n        fetch(path).then(res => res.json()).then(json => {\r\n          this.json = json;\r\n          this.setup();\r\n          if (json.image) {\r\n            const _path = path.startsWith(\"/\") ? path : \"./\" + path;\r\n            const basePath = _path.substring(0, _path.lastIndexOf(\"/\") + 1);\r\n            Flow.resolve()\r\n              .then(() => {\r\n                this.image = phina.asset.Texture();\r\n                return this.image.load(basePath + json.image);\r\n              })\r\n              .then(() => {\r\n                const filename = json.image.replace(\".png\", \"_n.png\");\r\n                this.normalImage = phina.asset.Texture();\r\n                return this.normalImage.load(basePath + filename);\r\n              })\r\n              .then(() => resolve(this));\r\n          } else {\r\n            resolve(this);\r\n          }\r\n        });\r\n      });\r\n    },\r\n\r\n    setup: function () {\r\n      this.tilewidth = this.json.tilewidth;\r\n      this.tileheight = this.json.tileheight;\r\n      this.imagewidth = this.json.imagewidth;\r\n      this.imageheight = this.json.imageheight;\r\n      this.cols = this.imagewidth / this.json.tilewidth;\r\n      this.rows = this.imageheight / this.json.tileheight;\r\n    },\r\n\r\n    calcUv: function (cell) {\r\n      const index = cell - this.firstgid;\r\n      const u0 = (index % this.cols) * this.tilewidth / this.imagewidth;\r\n      const u1 = u0 + this.tilewidth / this.imagewidth;\r\n      const v0 = (Math.floor(index / this.cols) * this.tileheight) / this.imageheight;\r\n      const v1 = v0 + this.tileheight / this.imageheight;\r\n\r\n      return [\r\n        u0, v1,\r\n        u1, v1,\r\n        u0, v0,\r\n        u1, v0,\r\n      ];\r\n    },\r\n  });\r\n\r\n  phina.asset.AssetLoader.register('tiled', function (key, src) {\r\n    var asset = TiledAsset();\r\n    return asset.load(src);\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  let TEXTURE = null;\r\n\r\n  phina.define(\"Middle1\", {\r\n    superClass: \"Enemy\",\r\n\r\n    init: function (params) {\r\n      this.superInit(({}).$extend({}, params));\r\n\r\n      if (TEXTURE == null) TEXTURE = ShipTextureGenerator.gen(3, 4444);\r\n\r\n      this.hp = 15;\r\n      this.r = 30;\r\n      this.toX = params.toX + CANVAS_WIDTH * 0.5;\r\n\r\n      this.fromJSON({\r\n        children: {\r\n          body: {\r\n            className: \"Sprite\",\r\n            arguments: [TEXTURE],\r\n          },\r\n        },\r\n      });\r\n\r\n      this.on(\"enter\", () => this.flare(\"attack\"));\r\n\r\n      this.on(\"killed\", () => {\r\n        this.flare(\"effect\", { type: \"middleExplosion\" });\r\n      });\r\n    },\r\n\r\n    start: function () {\r\n      this.tweener\r\n        .clear()\r\n        .to({\r\n          x: this.toX,\r\n        }, 2000, \"easeOutQuad\");\r\n\r\n      this.on(\"enterframe\", () => {\r\n        this.y += 1.2;\r\n\r\n        if (Fighter.instance.y < this.y) {\r\n          this.pauseAttack();\r\n        } else {\r\n          this.resumeAttack();\r\n        }\r\n\r\n        if (this.entered && !this.inWorld()) {\r\n          this.remove();\r\n        }\r\n      });\r\n    },\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  let TEXTURE = null;\r\n\r\n  phina.define(\"TankSmall\", {\r\n    superClass: \"Enemy\",\r\n\r\n    init: function (params) {\r\n      params = ({}).$extend({\r\n        speed: 0.75,\r\n      }, params);\r\n      this.superInit(params);\r\n\r\n      if (TEXTURE == null) TEXTURE = ShipTextureGenerator.gen(2, 3333);\r\n\r\n      this.hp = 8;\r\n      this.r = 20;\r\n      this.type = \"ground\";\r\n      this.vx = Math.cos(params.direction) * params.speed;\r\n      this.vy = Math.sin(params.direction) * params.speed;\r\n      this.rotation = 90 + params.direction.toDegree();\r\n\r\n      this.fromJSON({\r\n        children: {\r\n          body: {\r\n            className: \"Sprite\",\r\n            arguments: [TEXTURE],\r\n          },\r\n        },\r\n      });\r\n\r\n      this.on(\"enter\", () => this.flare(\"attack\"));\r\n      this.on(\"killed\", () => {\r\n        this.flare(\"effect\", { type: \"smallExplosion\" });\r\n      });\r\n    },\r\n\r\n    start: function () {\r\n      this.on(\"enterframe\", () => {\r\n        this.x += this.vx;\r\n        this.y += this.vy;\r\n\r\n        if (this.entered && !this.inWorld) {\r\n          this.remove();\r\n        }\r\n      });\r\n    },\r\n  });\r\n});\r\n","phina.namespace(() => {\r\n\r\n  let TEXTURE = null;\r\n\r\n  phina.define(\"Zako1\", {\r\n    superClass: \"Enemy\",\r\n\r\n    init: function (params) {\r\n      this.superInit(({}).$extend({}, params));\r\n\r\n      if (TEXTURE == null) TEXTURE = ShipTextureGenerator.gen(2, 1111);\r\n\r\n      this.hp = 3;\r\n      this.r = 20;\r\n\r\n      this.fromJSON({\r\n        children: {\r\n          body: {\r\n            className: \"AtlasSprite\",\r\n            arguments: {\r\n              atlas: \"enemies\",\r\n              frame: \"heri1_1.png\",\r\n            },\r\n          },\r\n        },\r\n      });\r\n\r\n      this.on(\"killed\", () => {\r\n        this.flare(\"effect\", { type: \"smallExplosion\" });\r\n      });\r\n    },\r\n\r\n    start: function () {\r\n      this.tweener\r\n        .clear()\r\n        .by({\r\n          y: 500\r\n        }, 1500, \"easeOutQuad\")\r\n        .call(() => this.flare(\"attack\"))\r\n        .wait(1000)\r\n        .by({\r\n          y: -500\r\n        }, 1500, \"easeInQuad\")\r\n        .call(() => this.remove());\r\n\r\n      this.odd = true;\r\n      this.on(\"enterframe\", (e) => {\r\n        this.body.scaleX = Fighter.instance.x < this.x ? 1 : -1;\r\n        if (this.odd) {\r\n          this.body.setFrame(\"heri1_1.png\");\r\n        } else {\r\n          this.body.setFrame(\"heri1_2.png\");\r\n        }\r\n        this.odd = !this.odd;\r\n      });\r\n    },\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  let TEXTURE = null;\r\n\r\n  phina.define(\"Zako2\", {\r\n    superClass: \"Enemy\",\r\n\r\n    init: function (params) {\r\n      this.superInit(({}).$extend({}, params));\r\n\r\n      if (TEXTURE == null) TEXTURE = ShipTextureGenerator.gen(2, 2222);\r\n\r\n      this.hp = 3;\r\n      this.r = 20;\r\n      this.a = Vector2(0, 0);\r\n      this.v = Vector2(0, 3);\r\n\r\n      this.fromJSON({\r\n        children: {\r\n          body: {\r\n            className: \"Sprite\",\r\n            arguments: [TEXTURE],\r\n          },\r\n        },\r\n      });\r\n\r\n      this.on(\"enter\", () => this.flare(\"attack\"));\r\n\r\n      this.on(\"killed\", () => {\r\n        this.flare(\"effect\", { type: \"smallExplosion\" });\r\n      });\r\n    },\r\n\r\n    start: function () {\r\n      this.on(\"enterframe\", () => {\r\n        this.a.set(Fighter.instance.x - this.x, Fighter.instance.y - this.y).normalize();\r\n        const angle = this.a.toDegree();\r\n        if (180 <= angle && angle < 270) {\r\n          this.a.fromDegree(180);\r\n        } else if (270 <= angle && angle < 360) {\r\n          this.a.fromDegree(0);\r\n        }\r\n        this.v.add(this.a.mul(0.3)).normalize().mul(7);\r\n\r\n        this.position.add(this.v);\r\n        this.rotation = 90 + angle;\r\n\r\n        if (Fighter.instance.y < this.y) {\r\n          this.pauseAttack();\r\n        } else {\r\n          this.resumeAttack();\r\n        }\r\n\r\n        if (this.entered && !this.inWorld()) {\r\n          this.remove();\r\n        }\r\n      });\r\n    },\r\n\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  phina.define(\"GLApp\", {\r\n    superClass: \"phina.display.DomApp\",\r\n\r\n    gl: null,\r\n\r\n    init: function (params) {\r\n      params = ({}).$extend(GLApp.defaults, params);\r\n      if (!params.query && !params.domElement) {\r\n        params.domElement = document.createElement('canvas');\r\n        if (params.append) {\r\n          document.body.appendChild(params.domElement);\r\n        }\r\n      }\r\n\r\n      this.superInit(params);\r\n\r\n      this.domElement.width = params.width;\r\n      this.domElement.height = params.height;\r\n\r\n      if (params.fit) {\r\n        this.fitScreen();\r\n      }\r\n\r\n      this.gl = this.domElement.getContext(\"webgl\");\r\n      this.renderer = GLAppRenderer(this.gl);\r\n    },\r\n\r\n    _draw: function () {\r\n      const gl = this.gl;\r\n\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n      this.renderer.render(this.currentScene);\r\n      gl.flush();\r\n    },\r\n\r\n    fitScreen: function () {\r\n      phina.graphics.Canvas.prototype.fitScreen.call(this);\r\n    },\r\n\r\n    _static: {\r\n      defaults: {\r\n        width: 640,\r\n        height: 960,\r\n        fit: true,\r\n        append: true,\r\n        fps: 60,\r\n      },\r\n    },\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  phina.define(\"GLAppRenderer\", {\r\n\r\n    gl: null,\r\n    context: null,\r\n\r\n    init: function (gl) {\r\n      gl.clearColor(0.1, 0.1, 0.2, 1.0);\r\n      gl.clearDepth(1.0);\r\n\r\n      gl.enable(gl.CULL_FACE);\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.enable(gl.BLEND);\r\n      gl.depthFunc(gl.LEQUAL);\r\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n\r\n      this.gl = gl;\r\n      this.context = GLContext2D();\r\n\r\n      this.spriteArrays = {};\r\n    },\r\n\r\n    addSpriteArray: function (name, atlas, max = 1000) {\r\n      const array = GLSpriteArray(this.gl, atlas, max);\r\n      this.spriteArrays[name] = array;\r\n      return array;\r\n    },\r\n\r\n    getSpriteArray: function (name) {\r\n      return this.spriteArrays[name];\r\n    },\r\n\r\n    render: function (scene) {\r\n      const gl = this.gl;\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n      this.renderChildren(scene);\r\n      for (let name in this.spriteArrays) {\r\n        const array = this.spriteArrays[name];\r\n        array.draw(gl);\r\n      }\r\n    },\r\n\r\n    renderChildren: function (obj) {\r\n      if (obj.children.length > 0) {\r\n        let tempChildren = obj.children.slice();\r\n        for (let i = 0, len = tempChildren.length; i < len; ++i) {\r\n          this.renderObject(tempChildren[i]);\r\n        }\r\n      }\r\n    },\r\n\r\n    renderObject: function (obj) {\r\n      if (obj.visible === false) return;\r\n\r\n      const context = this.context;\r\n\r\n      obj._calcWorldMatrix && obj._calcWorldMatrix();\r\n      obj._calcWorldAlpha && obj._calcWorldAlpha();\r\n\r\n      context.globalAlpha = obj._worldAlpha;\r\n      context.globalCompositeOperation = obj.blendMode;\r\n\r\n      obj.draw && obj.draw(this.gl);\r\n\r\n      let tempChildren = obj.children.slice();\r\n      for (let i = 0, len = tempChildren.length; i < len; ++i) {\r\n        this.renderObject(tempChildren[i]);\r\n      }\r\n    },\r\n  });\r\n\r\n  phina.define(\"GLContext2D\", {\r\n    init: function () {\r\n      this.globalAlpha = 1.0;\r\n      this.globalCompositeOperation = \"source-over\";\r\n    },\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  phina.define(\"GLLoadingScene\", {\r\n    superClass: \"GLScene\",\r\n\r\n    init: function (params) {\r\n      this.superInit(params);\r\n\r\n      const loader = phina.asset.AssetLoader();\r\n      loader.on(\"load\", () => {\r\n        this.app.popScene();\r\n      });\r\n      loader.load(params.assets);\r\n    },\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  phina.define(\"GLScene\", {\r\n    superClass: \"phina.app.Scene\",\r\n\r\n    init: function (params) {\r\n      this.superInit();\r\n      params = ({}).$extend(GLScene.defaults, params);\r\n    },\r\n\r\n    _static: {\r\n      defaults: {\r\n      },\r\n    },\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n  /**\r\n   * インスタンシングを使わないやつ\r\n   */\r\n  phina.define(\"GLSingleSprite\", {\r\n\r\n    superClass: \"DisplayElement\",\r\n\r\n    z: 0,\r\n\r\n    init: function (options) {\r\n      options = ({}).$extend(GLSingleSprite.defaults, options);\r\n      this.superInit(options);\r\n\r\n      let image = null;\r\n      if (typeof (options.image) == \"string\") {\r\n        image = AssetManager.get(\"image\", options.image);\r\n      } else {\r\n        image = options.image;\r\n      }\r\n\r\n      this.width = image.domElement.width;\r\n      this.height = image.domElement.height;\r\n\r\n      this.depthEnabled = options.depthEnabled;\r\n      this.blendMode = options.blendMode;\r\n      this.alphaEnabled = options.alphaEnabled;\r\n      this.brightness = options.brightness;\r\n\r\n      const gl = options.gl;\r\n      if (typeof (options.image) == \"string\") {\r\n        this.texture = TextureAsset.get(gl, options.image);\r\n        this.normalMap = TextureAsset.get(gl, options.image + \"_n\");\r\n        this.emissionMap = TextureAsset.get(gl, options.image + \"_e\");\r\n      } else {\r\n        this.texture = options.image;\r\n        this.normalMap = options.normalMap;\r\n        this.emissionMap = options.emissionMap;\r\n      }\r\n      if (this.normalMap == null) {\r\n        this.normalMap = TextureAsset.get(gl, GLSingleSprite.defaults.normalMap);\r\n      }\r\n      if (this.emissionMap == null) {\r\n        this.emissionMap = TextureAsset.get(gl, GLSingleSprite.defaults.emissionMap);\r\n      }\r\n\r\n      if (GLSingleSprite.drawable == null) {\r\n        const program = phigl.Program(gl)\r\n          .attach(\"glsinglesprite.vs\")\r\n          .attach(\"glsinglesprite.fs\")\r\n          .link();\r\n        GLSingleSprite.drawable = phigl.Drawable(gl)\r\n          .setProgram(program)\r\n          .setIndexValues([0, 1, 2, 1, 3, 2])\r\n          .declareAttributes(\"position\", \"uv\")\r\n          .setAttributeDataArray([{\r\n            unitSize: 2,\r\n            data: [\r\n              0, 1,\r\n              1, 1,\r\n              0, 0,\r\n              1, 0,\r\n            ]\r\n          }, {\r\n            unitSize: 2,\r\n            data: [\r\n              0, 1,\r\n              1, 1,\r\n              0, 0,\r\n              1, 0,\r\n            ],\r\n          },])\r\n          .createVao()\r\n          .declareUniforms(\r\n            \"instanceActive\",\r\n            \"instancePosition\",\r\n            \"instanceSize\",\r\n            \"instanceAlphaEnabled\",\r\n            \"instanceAlpha\",\r\n            \"instanceBrightness\",\r\n            \"cameraMatrix0\",\r\n            \"cameraMatrix1\",\r\n            \"cameraMatrix2\",\r\n            \"screenSize\",\r\n            \"texture\",\r\n            \"texture_n\",\r\n            \"texture_e\",\r\n            \"ambientColor\",\r\n            \"lightColor\",\r\n            \"lightPower\",\r\n            \"lightPosition\",\r\n          );\r\n      }\r\n    },\r\n\r\n    setZ: function (v) {\r\n      this.z = v;\r\n      return this;\r\n    },\r\n\r\n    draw: function (gl) {\r\n      const drawable = GLSingleSprite.drawable;\r\n\r\n      if (this.depthEnabled) {\r\n        gl.enable(gl.DEPTH_TEST);\r\n        gl.depthFunc(gl.LEQUAL);\r\n      } else {\r\n        gl.disable(gl.DEPTH_TEST);\r\n      }\r\n\r\n      if (this.blendMode === \"source-over\") {\r\n        gl.enable(gl.BLEND);\r\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n      } else if (this.options.blendMode === \"lighter\") {\r\n        gl.enable(gl.BLEND);\r\n        gl.blendFunc(gl.ONE, gl.ONE);\r\n      } else {\r\n        gl.disable(gl.BLEND);\r\n      }\r\n\r\n      const m = this._worldMatrix;\r\n      const uni = drawable.uniforms;\r\n      uni[\"instanceActive\"].setValue((this.parent && this.visible) ? 1 : 0);\r\n      if (this.parent && this.visible) {\r\n        uni[\"instancePosition\"].setValue([-this.width * this.originX, -this.height * this.originY, this.z]);\r\n        uni[\"instanceSize\"].setValue([this.width, this.height]);\r\n        uni[\"instanceAlphaEnabled\"].setValue(this.alphaEnabled ? 1 : 0);\r\n        uni[\"instanceAlpha\"].setValue(this._worldAlpha);\r\n        uni[\"instanceBrightness\"].setValue(this.brightness);\r\n        uni[\"cameraMatrix0\"].setValue([m.m00, m.m10]);\r\n        uni[\"cameraMatrix1\"].setValue([m.m01, m.m11]);\r\n        uni[\"cameraMatrix2\"].setValue([m.m02, m.m12]);\r\n        uni[\"screenSize\"].setValue([CANVAS_WIDTH, CANVAS_HEIGHT]);\r\n        uni[\"texture\"].setValue(0).setTexture(this.texture);\r\n        uni[\"texture_n\"].setValue(1).setTexture(this.normalMap);\r\n        uni[\"texture_e\"].setValue(2).setTexture(this.emissionMap);\r\n        uni[\"ambientColor\"].setValue([0.1, 0.1, 0.1, 1.0]);\r\n        for (let i = 0; i < 10; i++) {\r\n          uni[`lightColor[${i}]`].setValue([1.0, 1.0, 1.0, 1.0]);\r\n          uni[`lightPower[${i}]`].setValue(lightPower);\r\n          uni[`lightPosition[${i}]`].setValue(pos[i]);\r\n        }\r\n      }\r\n\r\n      drawable.draw();\r\n    },\r\n\r\n    _static: {\r\n      defaults: {\r\n        depthEnabled: true,\r\n        blendMode: \"source-over\",\r\n        alphaEnabled: false,\r\n        brightness: 1.0,\r\n        normalMap: \"no_normal\",\r\n        emissionMap: \"black\",\r\n      },\r\n      drawable: null,\r\n    },\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  phina.define(\"GLSpriteArray\", {\r\n\r\n    init: function (gl, atlas, max, options) {\r\n      options = ({}).$extend(GLSpriteArray.defaults, options);\r\n\r\n      this.gl = gl;\r\n      this.indexPool = Array.range(0, max);\r\n      this.instances = [];\r\n\r\n      this.atlas = phina.asset.AssetManager.get(\"atlas\", atlas);\r\n\r\n      this.image = this.atlas.images[Object.keys(this.atlas.images)[0]];\r\n      this.texture = phigl.Texture(gl, this.image);\r\n      this.max = max;\r\n\r\n      this.depthEnabled = options.depthEnabled;\r\n      this.blendMode = options.blendMode;\r\n\r\n      if (GLSpriteArray.drawable == null) {\r\n        const ext = phigl.Extensions.getInstancedArrays(gl);\r\n\r\n        const program = phigl.Program(gl)\r\n          .attach(\"glsprite.vs\")\r\n          .attach(\"glsprite.fs\")\r\n          .link();\r\n\r\n        console.log(\"drawable start\");\r\n\r\n        GLSpriteArray.drawable = phigl.InstancedDrawable(gl, ext)\r\n          .setProgram(program)\r\n          .setIndexValues([0, 1, 2, 1, 3, 2])\r\n          .declareAttributes(\"posuv\")\r\n          .setAttributeDataArray([{\r\n            // position, uv\r\n            unitSize: 2,\r\n            data: [\r\n              0, 1,\r\n              1, 1,\r\n              0, 0,\r\n              1, 0,\r\n            ],\r\n          },])\r\n          .createVao()\r\n          .declareInstanceAttributes(\r\n            \"instanceUvMatrix0\",\r\n            \"instanceUvMatrix1\",\r\n            \"instanceUvMatrixN0\",\r\n            \"instanceUvMatrixN1\",\r\n            \"instanceUvMatrixE0\",\r\n            \"instanceUvMatrixE1\",\r\n            \"instancePosition\",\r\n            \"instanceSize\",\r\n            \"cameraMatrix0\",\r\n            \"cameraMatrix1\",\r\n          )\r\n          .declareUniforms(\r\n            \"screenSize\",\r\n            \"texture\",\r\n            \"ambientColor\",\r\n            \"lightColor\",\r\n            \"lightPower\",\r\n            \"lightPosition\",\r\n          );\r\n\r\n        console.log(\"drawable ok\");\r\n      }\r\n\r\n      this.array = [];\r\n      for (let i = 0; i < max; i++) {\r\n        this.array.push(...[\r\n          // uv matrix\r\n          1, 0,\r\n          0, 1,\r\n          0, 0,\r\n          // uv matrix normal\r\n          1, 0,\r\n          0, 1,\r\n          0, 0,\r\n          // // uv matrix emission\r\n          1, 0,\r\n          0, 1,\r\n          0, 0,\r\n          // sprite position\r\n          0, 0, 0,\r\n          // sprite size ( + active)\r\n          0, 0, 0,\r\n          // camera matrix\r\n          1, 0,\r\n          0, 1,\r\n          0, 0,\r\n        ]);\r\n      }\r\n    },\r\n\r\n    draw: function (gl) {\r\n      const drawable = GLSpriteArray.drawable;\r\n\r\n      if (this.depthEnabled) {\r\n        gl.enable(gl.DEPTH_TEST);\r\n        gl.depthFunc(gl.LEQUAL);\r\n      } else {\r\n        gl.disable(gl.DEPTH_TEST);\r\n      }\r\n\r\n      if (this.blendMode === \"source-over\") {\r\n        gl.enable(gl.BLEND);\r\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n      } else if (this.blendMode === \"lighter\") {\r\n        gl.enable(gl.BLEND);\r\n        gl.blendFunc(gl.ONE, gl.ONE);\r\n      } else {\r\n        gl.disable(gl.BLEND);\r\n      }\r\n\r\n      for (let i = 0, len = this.instances.length; i < len; i++) {\r\n        this.instances[i].updateAttributes(this.array);\r\n      }\r\n\r\n      const uni = drawable.uniforms;\r\n      uni[\"screenSize\"].setValue([CANVAS_WIDTH, CANVAS_HEIGHT]);\r\n      uni[\"texture\"].setValue(0).setTexture(this.texture);\r\n      uni[\"ambientColor\"].setValue([0.1, 0.1, 0.1, 1.0]);\r\n      for (let i = 0; i < 10; i++) {\r\n        uni[`lightColor[${i}]`].setValue([1.0, 1.0, 1.0, 1.0]);\r\n        uni[`lightPower[${i}]`].setValue(lightPower);\r\n        uni[`lightPosition[${i}]`].setValue(pos[i]);\r\n      }\r\n\r\n      drawable.setInstanceAttributeData(this.array);\r\n      drawable.draw(this.max);\r\n    },\r\n\r\n    dispose: function () {\r\n\r\n    },\r\n\r\n    _static: {\r\n      defaults: {\r\n        depthEnabled: true,\r\n        blendMode: \"source-over\",\r\n      },\r\n      drawable: null,\r\n    },\r\n  });\r\n\r\n  phina.define(\"GLSprite\", {\r\n    superClass: \"phina.display.DisplayElement\",\r\n\r\n    init: function (params) {\r\n      params = ({}).$extend(GLSprite.defaults, params);\r\n      this.superInit(params);\r\n\r\n      this.spriteArray = params.spriteArray;\r\n      this.alphaEnabled = params.alphaEnabled;\r\n      this.brightness = params.brightness;\r\n      if (this.alphaEnabled) {\r\n        this.instanceIndex = this.spriteArray.indexPool.pop();\r\n      } else {\r\n        this.instanceIndex = this.spriteArray.indexPool.shift();\r\n      }\r\n      this.uvMatrix = Matrix33();\r\n      this.uvMatrixN = Matrix33();\r\n      this.uvMatrixE = Matrix33();\r\n\r\n      this.setImage(params.image);\r\n      this.setNormalMap(params.normalMap);\r\n      this.setEmissionMap(params.emissionMap);\r\n\r\n      this.spriteArray.instances.push(this);\r\n\r\n      this.z = 0;\r\n    },\r\n\r\n    setImage: function (image) {\r\n      const frame = this.spriteArray.atlas.getFrameByName(image);\r\n      const imgW = this.spriteArray.image.domElement.width;\r\n      const imgH = this.spriteArray.image.domElement.height;\r\n\r\n      const f = frame.frame;\r\n      const texX = f.x;\r\n      const texY = f.y;\r\n      const texW = f.w;\r\n      const texH = f.h;\r\n\r\n      const uvm = this.uvMatrix;\r\n      uvm.m00 = texW / imgW;\r\n      uvm.m01 = 0;\r\n      uvm.m10 = 0;\r\n      uvm.m11 = texH / imgH;\r\n      uvm.m02 = texX / imgW;\r\n      uvm.m12 = texY / imgH;\r\n\r\n      this.width = f.w;\r\n      this.height = f.h;\r\n    },\r\n\r\n    setNormalMap: function (image) {\r\n      const frame = this.spriteArray.atlas.getFrameByName(image);\r\n      const imgW = this.spriteArray.image.domElement.width;\r\n      const imgH = this.spriteArray.image.domElement.height;\r\n\r\n      const f = frame.frame;\r\n      const texX = f.x;\r\n      const texY = f.y;\r\n      const texW = f.w;\r\n      const texH = f.h;\r\n\r\n      const uvm = this.uvMatrixN;\r\n      uvm.m00 = texW / imgW;\r\n      uvm.m01 = 0;\r\n      uvm.m10 = 0;\r\n      uvm.m11 = texH / imgH;\r\n      uvm.m02 = texX / imgW;\r\n      uvm.m12 = texY / imgH;\r\n    },\r\n\r\n    setEmissionMap: function (image) {\r\n      const frame = this.spriteArray.atlas.getFrameByName(image);\r\n      const imgW = this.spriteArray.image.domElement.width;\r\n      const imgH = this.spriteArray.image.domElement.height;\r\n\r\n      const f = frame.frame;\r\n      const texX = f.x;\r\n      const texY = f.y;\r\n      const texW = f.w;\r\n      const texH = f.h;\r\n\r\n      const uvm = this.uvMatrixE;\r\n      uvm.m00 = texW / imgW;\r\n      uvm.m01 = 0;\r\n      uvm.m10 = 0;\r\n      uvm.m11 = texH / imgH;\r\n      uvm.m02 = texX / imgW;\r\n      uvm.m12 = texY / imgH;\r\n    },\r\n\r\n    setZ: function (v) {\r\n      this.z = v;\r\n      return this;\r\n    },\r\n\r\n    setAlpha: function (v) {\r\n      this.alpha = v;\r\n      return this;\r\n    },\r\n\r\n    setBrightness: function (v) {\r\n      this.brightness = v;\r\n      return this;\r\n    },\r\n\r\n    dispose: function () {\r\n      if (this.alphaEnabled) {\r\n        this.spriteArray.indexPool.push(this.instanceIndex);\r\n      } else {\r\n        this.spriteArray.indexPool.unshift(this.instanceIndex);\r\n      }\r\n      this.spriteArray.instances.erase(this);\r\n      this.instanceIndex = undefined;\r\n    },\r\n\r\n    updateAttributes: function (array) {\r\n      if (this.instanceIndex === undefined) return;\r\n\r\n      const idx = this.instanceIndex;\r\n      const uvm = this.uvMatrix;\r\n      const uvmN = this.uvMatrixN;\r\n      const uvmE = this.uvMatrixE;\r\n      const m = this._worldMatrix;\r\n\r\n      const size = 30;\r\n\r\n      // active\r\n      array[idx * size + 23] = (this.parent && this.visible) ? 1 : 0;\r\n      if (this.parent && this.visible) {\r\n        // uv matrix\r\n        array[idx * size + 0] = uvm.m00;\r\n        array[idx * size + 1] = uvm.m10;\r\n        array[idx * size + 2] = uvm.m01;\r\n        array[idx * size + 3] = uvm.m11;\r\n        array[idx * size + 4] = uvm.m02;\r\n        array[idx * size + 5] = uvm.m12;\r\n        // uv matrix normal\r\n        array[idx * size + 6] = uvmN.m00;\r\n        array[idx * size + 7] = uvmN.m10;\r\n        array[idx * size + 8] = uvmN.m01;\r\n        array[idx * size + 9] = uvmN.m11;\r\n        array[idx * size + 10] = uvmN.m02;\r\n        array[idx * size + 11] = uvmN.m12;\r\n        // // uv matrix emission\r\n        array[idx * size + 12] = uvmE.m00;\r\n        array[idx * size + 13] = uvmE.m10;\r\n        array[idx * size + 14] = uvmE.m01;\r\n        array[idx * size + 15] = uvmE.m11;\r\n        array[idx * size + 16] = uvmE.m02;\r\n        array[idx * size + 17] = uvmE.m12;\r\n        // sprite position\r\n        array[idx * size + 18] = -this.width * this.originX;\r\n        array[idx * size + 19] = -this.height * this.originY;\r\n        array[idx * size + 20] = this.z;\r\n        // sprite size\r\n        array[idx * size + 21] = this.width;\r\n        array[idx * size + 22] = this.height;\r\n        // camera matrix\r\n        array[idx * size + 24] = m.m00;\r\n        array[idx * size + 25] = m.m10;\r\n        array[idx * size + 26] = m.m01;\r\n        array[idx * size + 27] = m.m11;\r\n        array[idx * size + 28] = m.m02;\r\n        array[idx * size + 29] = m.m12;\r\n      }\r\n    },\r\n\r\n    _static: {\r\n      defaults: {\r\n        alphaEnabled: false,\r\n        normalMap: \"no_normal.png\",\r\n        emissionMap: \"black.png\"\r\n      },\r\n    },\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  phina.define(\"GLTiledMap\", {\r\n    superClass: \"DisplayElement\",\r\n\r\n    z: 0,\r\n\r\n    init: function (options) {\r\n      options = ({}).$extend(GLTiledMap.defaults, options);\r\n      this.superInit(options);\r\n\r\n      this.depthEnabled = options.depthEnabled;\r\n      this.alphaEnabled = options.alphaEnabled;\r\n      this.brightness = options.brightness;\r\n      this.blendMode = options.blendMode;\r\n\r\n      const gl = options.gl;\r\n\r\n      if (typeof (options.tiledAsset) == \"string\") {\r\n        this.tiledAsset = AssetManager.get(\"tiled\", options.tiledAsset);\r\n      } else {\r\n        this.tiledAsset = options.tiledAsset;\r\n      }\r\n      this.layer = options.layer;\r\n\r\n      const tilesets = this.tiledAsset.tilesets;\r\n      this.textures = tilesets.map(ts => phigl.Texture(gl, ts.image));\r\n      this.normalMaps = tilesets.map(ts => phigl.Texture(gl, ts.normalImage));\r\n\r\n      const cols = this.tiledAsset.json.width;\r\n      const rows = this.tiledAsset.json.height;\r\n      this.tilewidth = this.tiledAsset.json.tilewidth;\r\n      this.tileheight = this.tiledAsset.json.tileheight;\r\n\r\n      this.width = cols * this.tilewidth;\r\n      this.height = rows * this.tileheight;\r\n      this.originX = 0;\r\n      this.originY = 0;\r\n\r\n      const data = this.tiledAsset.json.layers[this.layer].data;\r\n\r\n      const indices = [];\r\n      const positions = [];\r\n      const textureIndices = [];\r\n      const uvs = [];\r\n      tilesets.push({ firstgid: Number.MAX_VALUE });\r\n      for (let y = 0; y < rows; y++) {\r\n        for (let x = 0; x < cols; x++) {\r\n          const idx = y * cols + x;\r\n          const cell = data[idx];\r\n\r\n          if (cell == 0) continue;\r\n\r\n          const textureIndex = tilesets.indexOf(tilesets.find(ts => cell < ts.firstgid)) - 1;\r\n          const uv = tilesets[textureIndex].calcUv(cell);\r\n\r\n          indices.push(\r\n            idx * 4 + 0,\r\n            idx * 4 + 1,\r\n            idx * 4 + 2,\r\n            idx * 4 + 1,\r\n            idx * 4 + 3,\r\n            idx * 4 + 2,\r\n          );\r\n          positions.push(\r\n            x + 0, y + 1,\r\n            x + 1, y + 1,\r\n            x + 0, y + 0,\r\n            x + 1, y + 0,\r\n          );\r\n          textureIndices.push(\r\n            textureIndex,\r\n            textureIndex,\r\n            textureIndex,\r\n            textureIndex,\r\n          );\r\n          uvs.push(...uv);\r\n        }\r\n      }\r\n      tilesets.pop();\r\n\r\n      if (GLTiledMap.program == null) {\r\n        GLTiledMap.program = phigl.Program(gl)\r\n          .attach(\"gltiledmap.vs\")\r\n          .attach(\"gltiledmap.fs\")\r\n          .link();\r\n      }\r\n      this.drawable = phigl.Drawable(gl)\r\n        .setProgram(GLTiledMap.program)\r\n        .setIndexValues(indices)\r\n        .declareAttributes(\"position\", \"uv\", \"textureIndex\")\r\n        .setAttributeDataArray([{\r\n          unitSize: 2,\r\n          data: positions,\r\n        }, {\r\n          unitSize: 2,\r\n          data: uvs,\r\n        }, {\r\n          unitSize: 1,\r\n          data: textureIndices,\r\n        }])\r\n        .createVao()\r\n        .declareUniforms(\r\n          \"instanceActive\",\r\n          \"instancePosition\",\r\n          \"instanceSize\",\r\n          \"instanceAlphaEnabled\",\r\n          \"instanceAlpha\",\r\n          \"instanceBrightness\",\r\n          \"cameraMatrix0\",\r\n          \"cameraMatrix1\",\r\n          \"cameraMatrix2\",\r\n          \"screenSize\",\r\n          \"texture\",\r\n          \"texture_n\",\r\n          \"ambientColor\",\r\n          \"lightColor\",\r\n          \"lightPower\",\r\n          \"lightPosition\",\r\n        );\r\n    },\r\n\r\n    setZ: function (v) {\r\n      this.z = v;\r\n      return this;\r\n    },\r\n\r\n    draw: function (gl) {\r\n      const drawable = this.drawable;\r\n\r\n      if (this.depthEnabled) {\r\n        gl.enable(gl.DEPTH_TEST);\r\n        gl.depthFunc(gl.LEQUAL);\r\n      } else {\r\n        gl.disable(gl.DEPTH_TEST);\r\n      }\r\n\r\n      if (this.blendMode === \"source-over\") {\r\n        gl.enable(gl.BLEND);\r\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n      } else if (this.options.blendMode === \"lighter\") {\r\n        gl.enable(gl.BLEND);\r\n        gl.blendFunc(gl.ONE, gl.ONE);\r\n      } else {\r\n        gl.disable(gl.BLEND);\r\n      }\r\n\r\n      const m = this._worldMatrix;\r\n      const uni = drawable.uniforms;\r\n      uni[\"instanceActive\"].setValue((this.parent && this.visible) ? 1 : 0);\r\n      if (this.parent && this.visible) {\r\n        uni[\"instancePosition\"].setValue([-this.width * this.originX, -this.height * this.originY, this.z]);\r\n        uni[\"instanceSize\"].setValue([this.tilewidth, this.tileheight]);\r\n        uni[\"instanceAlphaEnabled\"].setValue(this.alphaEnabled ? 1 : 0);\r\n        uni[\"instanceAlpha\"].setValue(this._worldAlpha);\r\n        uni[\"instanceBrightness\"].setValue(this.brightness);\r\n        uni[\"cameraMatrix0\"].setValue([m.m00, m.m10]);\r\n        uni[\"cameraMatrix1\"].setValue([m.m01, m.m11]);\r\n        uni[\"cameraMatrix2\"].setValue([m.m02, m.m12]);\r\n        uni[\"screenSize\"].setValue([CANVAS_WIDTH, CANVAS_HEIGHT]);\r\n        for (let i = 0, len = this.textures.length; i < len; i++) {\r\n          uni[`texture[${i}]`].setValue(i).setTexture(this.textures[i]);\r\n        }\r\n        for (let i = 0, len = this.normalMaps.length; i < len; i++) {\r\n          uni[`texture_n[${i}]`].setValue(8 + i).setTexture(this.normalMaps[i]);\r\n        }\r\n        uni[\"ambientColor\"].setValue([0.1, 0.1, 0.1, 1.0]);\r\n        for (let i = 0; i < 10; i++) {\r\n          uni[`lightColor[${i}]`].setValue([1.0, 1.0, 1.0, 1.0]);\r\n          uni[`lightPower[${i}]`].setValue(lightPower);\r\n          uni[`lightPosition[${i}]`].setValue(pos[i]);\r\n        }\r\n      }\r\n\r\n      drawable.draw();\r\n    },\r\n\r\n    _static: {\r\n      defaults: {\r\n        layer: 0,\r\n        depthEnabled: true,\r\n        blendMode: \"source-over\",\r\n        alphaEnabled: false,\r\n        brightness: 1.0,\r\n      },\r\n      program: null,\r\n    }\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  phina.define(\"TextureAsset\", {\r\n    _static: {\r\n      get: function (gl, name) {\r\n        const AssetManager = phina.asset.AssetManager;\r\n\r\n        if (AssetManager.get(\"texture\", name) == null) {\r\n          const img = AssetManager.get(\"image\", name);\r\n          if (img == null) {\r\n            console.log(\"ないよ \" + name);\r\n            return;\r\n          }\r\n          AssetManager.set(\"texture\", name, phigl.Texture(gl, img));\r\n        }\r\n\r\n        return AssetManager.get(\"texture\", name);\r\n      },\r\n    },\r\n  });\r\n\r\n});\r\n","phina.namespace(() => {\r\n\r\n  phina.define(\"Stage1\", {\r\n    superClass: \"StageSequencer\",\r\n\r\n    init: function () {\r\n      this.superInit()\r\n    },\r\n\r\n    gen: function* () {\r\n      let R = Random(12345);\r\n      let cp = 0;\r\n      let a = 0;\r\n\r\n      this.changeScroll(0, 0.5, 1);\r\n      yield 2000;\r\n\r\n      cp += 1;\r\n      if (this.checkPoint < cp) {\r\n        console.log(\"area \" + cp);\r\n        a = (30).toRadian();\r\n        for (let i = 0; i < 5; i++) {\r\n          const pos0 = PositionHelper.rotate(-50 * i, -25, a);\r\n          this.launchEnemy(\"TankSmall\", { bulletml: \"zako\", wait: 0, direction: a }, -300 + pos0, -100 + pos0, false);\r\n          const pos1 = PositionHelper.rotate(-50 * i, 25, a);\r\n          this.launchEnemy(\"TankSmall\", { bulletml: \"zako\", wait: 0, direction: a }, -300 + pos1, -100 + pos1, false);\r\n        }\r\n        a = (170).toRadian();\r\n        for (let i = 0; i < 5; i++) {\r\n          this.launchEnemy(\"TankSmall\", { bulletml: \"zako\", wait: 200, direction: a }, 400 + Math.cos(a) * -50 * i, -200 + Math.sin(a) * -50 * i, false);\r\n        }\r\n        yield 1500;\r\n        for (let i = 0; i < 3; i++) {\r\n          this.launchEnemy(\"Zako1\", { bulletml: \"zako\", wait: i * 100 }, -150 + R.randint(-3, 3) * 20, -150 + R.randint(-3, 3) * 20);\r\n        }\r\n        yield 1500;\r\n        for (let i = 0; i < 3; i++) {\r\n          this.launchEnemy(\"Zako1\", { bulletml: \"zako\", wait: i * 100 }, 150 + R.randint(-3, 3) * 20, -150 + R.randint(-3, 3) * 20);\r\n        }\r\n        yield 1500;\r\n        for (let i = 0; i < 3; i++) {\r\n          this.launchEnemy(\"Zako1\", { bulletml: \"zako\", wait: i * 100 }, -150 + R.randint(-3, 3) * 20, -150 + R.randint(-3, 3) * 20);\r\n          this.launchEnemy(\"Zako1\", { bulletml: \"zako\", wait: i * 100 }, 150 + R.randint(-3, 3) * 20, -150 + R.randint(-3, 3) * 20);\r\n        }\r\n\r\n        while (this.enemies.some(e => e.parent)) yield 10;\r\n        this.flare(\"checkpoint\");\r\n      }\r\n\r\n      cp += 1;\r\n      if (this.checkPoint < cp) {\r\n        console.log(\"area \" + cp);\r\n        a = (-180).toRadian();\r\n        for (let i = 0; i < 5; i++) {\r\n          this.launchEnemy(\"TankSmall\", { bulletml: \"zako\", wait: 0, direction: a }, 300 + Math.cos(a) * -50 * i, -100 + Math.sin(a) * -50 * i, false);\r\n        }\r\n        a = (-20).toRadian();\r\n        for (let i = 0; i < 5; i++) {\r\n          this.launchEnemy(\"TankSmall\", { bulletml: \"zako\", wait: 0, direction: a }, -300 + Math.cos(a) * -50 * i, 500 + Math.sin(a) * -50 * i, false);\r\n        }\r\n        a = (90).toRadian();\r\n        for (let i = 0; i < 5; i++) {\r\n          this.launchEnemy(\"TankSmall\", { bulletml: \"zako\", wait: 0, direction: a }, 20 + Math.cos(a) * -50 * i, -140 + Math.sin(a) * -50 * i, false);\r\n        }\r\n        yield 1500;\r\n        for (let i = 0; i < 10; i++) {\r\n          this.launchEnemy(\"Zako1\", { bulletml: \"zako\", wait: i * 100 }, -150 + R.randint(-3, 3) * 20, -150 + R.randint(-3, 3) * 20);\r\n          this.launchEnemy(\"Zako1\", { bulletml: \"zako\", wait: i * 100 }, 150 + R.randint(-3, 3) * 20, -150 + R.randint(-3, 3) * 20);\r\n        }\r\n\r\n        while (this.enemies.some(e => e.parent)) yield 10;\r\n        this.flare(\"checkpoint\");\r\n      }\r\n\r\n      cp += 1;\r\n      if (this.checkPoint < cp) {\r\n        console.log(\"area \" + cp);\r\n        yield 1500;\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 0 }, -100, -100);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 100 }, -150, -180);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 200 }, -80, -140);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 300 }, 100, -100);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 400 }, 150, -180);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 500 }, 80, -140);\r\n\r\n        yield 1500;\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 0 }, -100, -100);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 100 }, -150, -180);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 200 }, -80, -140);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 300 }, 100, -100);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 400 }, 150, -180);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 500 }, 80, -140);\r\n\r\n        yield 1500;\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 0 }, -100, -100);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 100 }, -150, -180);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 200 }, -80, -140);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 300 }, 100, -100);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 400 }, 150, -180);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 500 }, 80, -140);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 600 }, -100, -100);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 700 }, -150, -180);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 800 }, -80, -140);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 900 }, 100, -100);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 1000 }, 150, -180);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 1100 }, 80, -140);\r\n\r\n        while (this.enemies.some(e => e.parent)) yield 10;\r\n        this.flare(\"checkpoint\");\r\n      }\r\n\r\n      cp += 1;\r\n      if (this.checkPoint < cp) {\r\n        console.log(\"area \" + cp);\r\n        yield 1500;\r\n\r\n        this.launchEnemy(\"Middle1\", { bulletml: \"middle1\", wait: 0, toX: -30 }, 0, -100);\r\n        this.launchEnemy(\"Middle1\", { bulletml: \"middle1\", wait: 600, toX: 60 }, 0, -100);\r\n        this.launchEnemy(\"Middle1\", { bulletml: \"middle1\", wait: 1200, toX: -180 }, 0, -100);\r\n        this.launchEnemy(\"Middle1\", { bulletml: \"middle1\", wait: 1800, toX: 150 }, 0, -100);\r\n\r\n        while (this.enemies.some(e => e.parent)) yield 10;\r\n        this.flare(\"checkpoint\");\r\n      }\r\n\r\n      cp += 1;\r\n      if (this.checkPoint < cp) {\r\n        console.log(\"area \" + cp);\r\n        yield 1500;\r\n\r\n        this.launchEnemy(\"Middle1\", { bulletml: \"middle1\", wait: 0, toX: -250 }, 0, -100);\r\n        this.launchEnemy(\"Middle1\", { bulletml: \"middle1\", wait: 0, toX: 250 }, 0, -100);\r\n        this.launchEnemy(\"Middle1\", { bulletml: \"middle1\", wait: 1200, toX: -250 }, 0, -100);\r\n        this.launchEnemy(\"Middle1\", { bulletml: \"middle1\", wait: 1200, toX: 250 }, 0, -100);\r\n        this.launchEnemy(\"Middle1\", { bulletml: \"middle1\", wait: 1800, toX: -250 }, 0, -100);\r\n        this.launchEnemy(\"Middle1\", { bulletml: \"middle1\", wait: 1800, toX: 250 }, 0, -100);\r\n\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 0 }, -100, -100);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 100 }, -150, -180);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 200 }, -80, -140);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 300 }, 100, -100);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 400 }, 150, -180);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 500 }, 80, -140);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 600 }, -100, -100);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 700 }, -150, -180);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 800 }, -80, -140);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 900 }, 100, -100);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 1000 }, 150, -180);\r\n        this.launchEnemy(\"Zako2\", { bulletml: \"zako\", wait: 1100 }, 80, -140);\r\n\r\n        while (this.enemies.some(e => e.parent)) yield 10;\r\n        this.flare(\"checkpoint\");\r\n      }\r\n    },\r\n\r\n  });\r\n\r\n});\r\n"]}