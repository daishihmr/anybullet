{"version":3,"sources":["phina.atlas.atlasanimator.js","phina.atlas.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"phina.atlas.js","sourcesContent":["phina.namespace(function() {\n\n  phina.define(\"phina.atlas.AtlasAnimator\", {\n    superClass: \"phina.accessory.Accessory\",\n\n    updateType: \"time\", // or \"frame\"\n\n    time: 0,\n    currentFrame: 0,\n    fps: 30,\n    loop: false,\n\n    fpu: 1, // frame per update.\n\n    _playing: false,\n    _bf: 0,\n\n    init: function(target) {\n      this.superInit(target);\n    },\n\n    update: function(app) {\n      if (this._playing) {\n        var frameTime;\n        if (this.updateType === \"time\") {\n          frameTime = 1000 / this.fps;\n          this.time += app.deltaTime;\n        } else if (this.updateType === \"frame\") {\n          frameTime = 1;\n          this.time += this.fpu;\n        }\n        this._bf = (this.time / frameTime).floor();\n\n        if (this.currentFrame === this._bf) {\n          return;\n        }\n        this.currentFrame = this._bf;\n        this.target.setFrame(~~this.currentFrame);\n        var frameLength = this.target.atlas.data.frames.length;\n        if (this.currentFrame >= frameLength - 1) {\n          this.flare(\"finish\");\n          if (this.loop) {\n            this.time = (this.time - frameLength * frameTime) % (frameLength * frameTime);\n          } else {\n            this.stop();\n          }\n        }\n      }\n    },\n\n    setUpdateType: function(v) {\n      this.updateType = v;\n      return this;\n    },\n\n    play: function() {\n      this.time = 0;\n      this._playing = true;\n      return this;\n    },\n\n    pause: function() {\n      this._playing = false;\n      return this;\n    },\n\n    resume: function() {\n      this._playing = true;\n      return this;\n    },\n\n    stop: function() {\n      this.time = 0;\n      this._playing = false;\n      return this;\n    },\n\n    _accessor: {\n      isPlaying: {\n        get: function() { return this._playing; },\n      },\n    },\n  });\n\n});\n","phina.namespace(function() {\n\n  phina.define(\"phina.asset.Atlas\", {\n    superClass: \"phina.asset.Asset\",\n\n    data: null,\n    images: null,\n\n    init: function() {\n      this.superInit();\n      this.images = {};\n      this.frameCache = {};\n    },\n\n    load: function(key, src) {\n      this.key = key;\n      if (typeof(src) === \"string\") {\n        this.src = [src];\n      } else {\n        this.src = src;\n      }\n      return phina.util.Flow(this._load.bind(this));\n    },\n\n    _load: function(resolve) {\n      var self = this;\n\n      var flows = self.src.map(function(src) {\n        var basePath = null;\n        if (src.indexOf('/') < 0) {\n          basePath = './';\n        } else {\n          basePath = src.substring(0, src.lastIndexOf('/') + 1);\n        }\n\n        return self._loadJson(src)\n          .then(function(data) {\n            return self._loadImage(data, basePath);\n          });\n      });\n\n      phina.util.Flow.all(flows)\n        .then(function(dataList) {\n          return self._mergeData(dataList);\n        })\n        .then(function() {\n          resolve(self);\n        });\n    },\n\n    _loadJson: function(src) {\n      var self = this;\n      return phina.util.Flow(function(resolve) {\n        var xml = new XMLHttpRequest();\n        xml.open('GET', src);\n        xml.onreadystatechange = function() {\n          if (xml.readyState === 4) {\n            if ([200, 201, 0].indexOf(xml.status) !== -1) {\n              var data = JSON.parse(xml.responseText);\n              resolve(data);\n            }\n          }\n        };\n        xml.send(null);\n      });\n    },\n\n    _loadImage: function(data, basePath) {\n      var self = this;\n      return phina.util.Flow(function(resolve) {\n        var image = phina.asset.Texture();\n        self.images[data.meta.image] = image;\n        image.load(basePath + data.meta.image).then(function() {\n          resolve(data);\n        });\n      });\n    },\n\n    _mergeData: function(dataList) {\n      var self = this;\n      this.data = {\n        frames: [],\n        meta: {\n          app: dataList[0].meta.appapp,\n          version: dataList[0].meta.version,\n          format: dataList[0].meta.format,\n          scale: dataList[0].meta.scale,\n          smartupdate: dataList[0].meta.smartupdate,\n        },\n      };\n      dataList.forEach(function(data) {\n        var frames = data.frames;\n        if (frames instanceof Array == false) {\n          frames = Object.keys(frames).map(function(key) {\n            var frame = frames[key];\n            frame.filename = key;\n            return frame;\n          });\n        }\n\n        frames.forEach(function(frame) {\n          frame.image = data.meta.image;\n          frame.size = data.meta.size;\n        });\n\n        self.data.frames = self.data.frames.concat(frames);\n      });\n\n      this.data.frames.sort(function(lhs, rhs) {\n        return (lhs.filename <= rhs.filename) ? -1 : 1;\n      });\n    },\n\n    getFrameByName: function(name) {\n      var frame = this.frameCache[name];\n      if (!frame) {\n        frame = this.frameCache[name] = this.data.frames.find(function(f) {\n          return f.filename === name;\n        });\n      }\n      return frame;\n    },\n\n    unpackAll: function() {\n      var self = this;\n      var data = self.data;\n      var frames = data.frames;\n      if (frames instanceof Array == false) {\n        frames = Object.keys(frames).map(function(key) {\n          var frame = frames[key];\n          frame.filename = key;\n          return frame;\n        });\n      }\n\n      return frames.reduce(function(ret, frame) {\n        var canvas = phina.graphics.Canvas();\n\n        var f = frame.frame;\n        var s = frame.spriteSourceSize;\n        var src = frame.sourceSize;\n        var p = frame.pivot;\n\n        var image = self.images[frame.image].domElement;\n\n        canvas.setSize(src.w, src.h);\n        if (!frame.rotated) {\n          canvas.context.drawImage(image,\n            f.x, f.y, f.w, f.h,\n            s.x, s.y, s.w, s.h\n          );\n        } else {\n          canvas.context.save();\n          canvas.context.translate(src.w * p.x, src.h * p.y);\n          canvas.context.rotate(Math.PI * -0.5);\n          canvas.context.translate(-src.h * p.y, -src.w * p.x);\n          canvas.context.drawImage(image,\n            f.x, f.y, f.h, f.w,\n            s.y, s.x, s.h, s.w\n          );\n          canvas.context.restore();\n        }\n\n        ret[frame.filename] = canvas;\n        return ret;\n      }, {});\n    },\n\n    unpack: function(frame) {\n      var data = this.data;\n      var frames = data.frames;\n      if (frames instanceof Array == false) {\n        frames = Object.keys(frames).map(function(key) {\n          var frame = frames[key];\n          frame.filename = key;\n          return frame;\n        });\n      }\n\n      var canvas = phina.graphics.Canvas();\n\n      var f = frame.frame;\n      var s = frame.spriteSourceSize;\n      var src = frame.sourceSize;\n      var p = frame.pivot;\n\n      var image = this.images[frame.image].domElement;\n\n      canvas.setSize(src.w, src.h);\n      if (!frame.rotated) {\n        canvas.context.drawImage(image,\n          f.x, f.y, f.w, f.h,\n          s.x, s.y, s.w, s.h\n        );\n      } else {\n        canvas.context.save();\n        canvas.context.translate(src.w * p.x, src.h * p.y);\n        canvas.context.rotate(Math.PI * -0.5);\n        canvas.context.translate(-src.h * p.y, -src.w * p.x);\n        canvas.context.drawImage(image,\n          f.x, f.y, f.h, f.w,\n          s.y, s.x, s.h, s.w\n        );\n        canvas.context.restore();\n      }\n\n      return canvas;\n    },\n\n    /**\n     * フレームを切り分けた配列をatlasFramesとしてAssetManagerにつっこむ\n     * すでに存在すれば、 AssetManagerから取得する\n     */ \n    getAtlasFrames: function() {\n      var self = this;\n      var atlasFrames = phina.asset.AssetManager.get('atlasFrames', self.key);\n      if (atlasFrames) {\n        return atlasFrames;\n      }\n      var data = self.data;\n      var frames = data.frames;\n      var meta = data.meta;\n      if (frames instanceof Array == false) {\n        frames = Object.keys(frames).map(function(key) {\n          var frame = frames[key];\n          frame.filename = key;\n          return frame;\n        });\n      }\n\n      atlasFrames = frames.map(function(frame) {\n        var key = self.key + \"/\" + frame.filename;\n        var canvas = phina.graphics.Canvas();\n\n        var f = frame.frame;\n        var s = frame.spriteSourceSize;\n        var src = frame.sourceSize;\n        var p = frame.pivot;\n\n        var image = self.images[frame.image].domElement;\n\n        canvas.setSize(s.w, s.h);\n        if (!frame.rotated) {\n          canvas.context.drawImage(image,\n            f.x, f.y, f.w, f.h,\n            0, 0, s.w, s.h\n          );\n        } else {\n          canvas.context.save();\n          canvas.context.translate(s.w * p.x, s.h * p.y);\n          canvas.context.rotate(Math.PI * -0.5);\n          canvas.context.translate(-s.h * p.y, -s.w * p.x);\n          canvas.context.drawImage(image,\n            f.x, f.y, f.h, f.w,\n            0, 0, s.h, s.w\n          );\n          canvas.context.restore();\n        }\n        canvas.frame = frame;\n        canvas.meta = meta;\n        phina.asset.AssetManager.set('image', key, canvas);\n        return canvas;\n      });\n\n      phina.asset.AssetManager.set('atlasFrames', self.key, atlasFrames);\n      return atlasFrames;\n    },\n\n  });\n\n  phina.asset.AssetLoader.register('atlas', function(key, src) {\n    var asset = phina.asset.Atlas();\n    return asset.load(key, src);\n  });\n\n  phina.define(\"phina.display.AtlasSprite\", {\n    superClass: \"phina.display.DisplayElement\",\n\n    init: function(options) {\n      options = ({}).$safe(options, phina.display.AtlasSprite.defaults);\n      this.superInit(options);\n      this.srcRect = phina.geom.Rect();\n      this.dstRect = phina.geom.Rect();\n      this.srcPivot = phina.geom.Vector2();\n      this.rotated = false;\n\n      this.atlas = phina.asset.AssetManager.get(\"atlas\", options.atlas);\n\n      this.setFrame(options.frame);\n\n      this.alpha = options.alpha;\n    },\n\n    setFrame: function(frameName) {\n      var atlas = this.atlas;\n      if (typeof (frameName) === \"string\") {\n        this.frame = atlas.getFrameByName(frameName);\n      } else {\n        this.frame = atlas.data.frames.at(frameName);\n      }\n\n      this.image = atlas.images[this.frame.image];\n\n      var f = this.frame.frame;\n      var sss = this.frame.spriteSourceSize;\n      var p = this.frame.pivot;\n      this.srcRect.set(f.x, f.y, f.w, f.h);\n      this.dstRect.set(sss.x, sss.y, sss.w, sss.h);\n      this.width = this.frame.sourceSize.w;\n      this.height = this.frame.sourceSize.h;\n      if (atlas.data.meta.scale != \"1\") {\n        var s = 1 / (+atlas.data.meta.scale);\n        this.dstRect.x *= s;\n        this.dstRect.y *= s;\n        this.dstRect.width *= s;\n        this.dstRect.height *= s;\n        this.width *= s;\n        this.height *= s;\n      }\n      this.srcPivot.set(p.x, p.y);\n      this.rotated = this.frame.rotated;\n\n      return this;\n    },\n\n    draw: function(canvas) {\n      var sr = this.srcRect;\n      var dr = this.dstRect;\n      var p = this.srcPivot;\n      var image = this.image.domElement;\n\n      if (!this.rotated) {\n        canvas.context.drawImage(image,\n          sr.x, sr.y, sr.width, sr.height, -this._width * this.originX + dr.x, -this._height * this.originY + dr.y, dr.width, dr.height\n        );\n      } else {\n        var ctx = canvas.context;\n        ctx.save();\n        ctx.rotate(Math.PI * -0.5);\n        ctx.drawImage(image,\n          sr.x, sr.y, sr.height, sr.width,\n          this._height * (1 - this.originY) - dr.height - dr.y, -this._width * this.originX + dr.x, dr.height, dr.width\n        );\n        ctx.restore();\n      }\n    },\n\n    _static: {\n      defaults: {\n        frame: 0,\n        alpha: 1,\n      },\n    },\n\n  });\n\n  phina.define(\"phina.display.AtlasFrameSprite\", {\n    superClass: \"phina.display.DisplayElement\",\n    _atlasIndex: 0,\n    init: function(options) {\n      if (typeof options === 'string') {\n        options = {\n          atlas: options,\n        };\n      }\n      options = ({}).$safe(options, phina.display.AtlasFrameSprite.defaults);\n      this.atlasName = options.atlas;\n      this.atlas = phina.asset.AssetManager.get('atlas', this.atlasName);\n      this.atlasFrames = this.atlas.getAtlasFrames();\n      this.superInit();\n      this.dstRect = phina.geom.Rect();\n      this.srcPivot = phina.geom.Vector2();\n\n      this.setImage(this.atlasName);\n      this.atlasIndex = options.atlasIndex;\n\n      this.alpha = options.alpha;\n    },\n\n    setImage: function(image, width, height) {\n      if (typeof image === 'string') {\n        this.atlasFrames = phina.asset.AssetManager.get('atlas', image).getAtlasFrames();\n        image = this.atlasFrames[this.atlasIndex];\n      }\n      this._image = image;\n      this.width = this._image.domElement.width;\n      this.height = this._image.domElement.height;\n\n      if (width) { this.width = width; }\n      if (height) { this.height = height; }\n\n      return this;\n    },\n\n    setFrame: function(atlasIndex) {\n      var image = this.image = this.atlasFrames.at(atlasIndex);\n      this.frame = image.frame;\n      var f = this.frame.frame;\n      var ss = this.frame.sourceSize;\n      var sss = this.frame.spriteSourceSize;\n      var p = this.frame.pivot;\n      var dr = this.dstRect;\n      dr.set(sss.x, sss.y, sss.w, sss.h);\n\n      dr.x -= ss.w * this.originX;\n      dr.y -= ss.h * this.originY;\n      if (image.meta.scale != \"1\") {\n        var s = 1 / (+image.meta.scale);\n        dr.x *= s;\n        dr.y *= s;\n        dr.width *= s;\n        dr.height *= s;\n        this.width *= s;\n        this.height *= s;\n      }\n      this.srcPivot.set(p.x, p.y);\n\n      return this;\n    },\n\n    draw: function(canvas) {\n      var dr = this.dstRect;\n      // 一旦使ってない\n      // var p = this.srcPivot;\n      var image = this.image.domElement;\n\n      canvas.context.drawImage(image, 0, 0, image.width, image.height, dr.x, dr.y, dr.width, dr.height);\n    },\n\n    _accessor: {\n      image: {\n        get: function() { return this._image; },\n        set: function(v) {\n          this.setImage(v);\n          return this;\n        }\n      },\n      atlasIndex: {\n        get: function() {\n          return this._atlasIndex;\n        },\n        set: function(v) {\n          this._atlasIndex = v;\n          this.setFrame(v);\n        },\n      }\n    },\n\n    _static: {\n      defaults: {\n        atlasIndex: 0,\n        alpha: 1,\n      },\n    },\n\n  });\n\n});"]}